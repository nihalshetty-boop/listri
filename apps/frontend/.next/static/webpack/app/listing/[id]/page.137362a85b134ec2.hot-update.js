"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/listing/[id]/page",{

/***/ "(app-pages-browser)/./hooks/useChatSocket.ts":
/*!********************************!*\
  !*** ./hooks/useChatSocket.ts ***!
  \********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useChatSocket: () => (/* binding */ useChatSocket)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/../../node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var sockjs_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! sockjs-client */ \"(app-pages-browser)/../../node_modules/sockjs-client/lib/entry.js\");\n/* harmony import */ var sockjs_client__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(sockjs_client__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _stomp_stompjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @stomp/stompjs */ \"(app-pages-browser)/../../node_modules/@stomp/stompjs/esm6/client.js\");\n\n\n\n// Global connection manager to prevent multiple connections per user\nconst connectionManager = new Map();\n// Message deduplication set to prevent processing the same message multiple times\nconst processedMessages = new Set();\nfunction useChatSocket(userId, onMessage, onConnect, onDisconnect) {\n    const clientRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const [connectionState, setConnectionState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"disconnected\");\n    const reconnectTimeoutRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const connectionAttemptsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const maxReconnectAttempts = 3;\n    const reconnectDelay = 3000;\n    const isInitializedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const onMessageRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(onMessage);\n    const onConnectRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(onConnect);\n    const onDisconnectRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(onDisconnect);\n    const isConnectingRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    // Update refs when callbacks change\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useChatSocket.useEffect\": ()=>{\n            onMessageRef.current = onMessage;\n        }\n    }[\"useChatSocket.useEffect\"], [\n        onMessage\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useChatSocket.useEffect\": ()=>{\n            onConnectRef.current = onConnect;\n        }\n    }[\"useChatSocket.useEffect\"], [\n        onConnect\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useChatSocket.useEffect\": ()=>{\n            onDisconnectRef.current = onDisconnect;\n        }\n    }[\"useChatSocket.useEffect\"], [\n        onDisconnect\n    ]);\n    const cleanup = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useChatSocket.useCallback[cleanup]\": ()=>{\n            if (reconnectTimeoutRef.current) {\n                clearTimeout(reconnectTimeoutRef.current);\n                reconnectTimeoutRef.current = null;\n            }\n        }\n    }[\"useChatSocket.useCallback[cleanup]\"], []);\n    const connect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useChatSocket.useCallback[connect]\": ()=>{\n            if (!userId || isConnectingRef.current) return;\n            // Check if there's already a connection for this user\n            const existingClient = connectionManager.get(userId);\n            if (existingClient && existingClient.connected) {\n                var _onConnectRef_current;\n                console.log(\"üîå Using existing WebSocket connection for user:\", userId);\n                clientRef.current = existingClient;\n                setConnectionState(\"connected\");\n                (_onConnectRef_current = onConnectRef.current) === null || _onConnectRef_current === void 0 ? void 0 : _onConnectRef_current.call(onConnectRef);\n                return;\n            }\n            // Clean up any existing connection\n            if (existingClient) {\n                try {\n                    existingClient.deactivate();\n                } catch (error) {\n                    console.warn(\"Error deactivating existing client:\", error);\n                }\n                connectionManager.delete(userId);\n            }\n            cleanup();\n            connectionAttemptsRef.current = 0;\n            isConnectingRef.current = true;\n            console.log(\"üîå Initializing new WebSocket connection for user:\", userId);\n            setConnectionState(\"connecting\");\n            try {\n                const socket = new (sockjs_client__WEBPACK_IMPORTED_MODULE_1___default())(\"http://localhost:8081/ws\");\n                const client = new _stomp_stompjs__WEBPACK_IMPORTED_MODULE_2__.Client({\n                    webSocketFactory: {\n                        \"useChatSocket.useCallback[connect]\": ()=>socket\n                    }[\"useChatSocket.useCallback[connect]\"],\n                    reconnectDelay: 0,\n                    heartbeatIncoming: 4000,\n                    heartbeatOutgoing: 4000,\n                    onConnect: {\n                        \"useChatSocket.useCallback[connect]\": ()=>{\n                            var _onConnectRef_current;\n                            console.log(\"‚úÖ WebSocket connected successfully for user:\", userId);\n                            connectionAttemptsRef.current = 0;\n                            isConnectingRef.current = false;\n                            setConnectionState(\"connected\");\n                            // Store the client in the global manager\n                            connectionManager.set(userId, client);\n                            clientRef.current = client;\n                            // Subscribe to user-specific private messages\n                            // This ensures only messages intended for this user are received\n                            client.subscribe(\"/user/\".concat(userId, \"/queue/messages\"), {\n                                \"useChatSocket.useCallback[connect]\": (message)=>{\n                                    try {\n                                        console.log(\"üì® Received private message for user\", userId, \":\", message.body);\n                                        const body = JSON.parse(message.body);\n                                        console.log(\"üì® Parsed private message:\", body);\n                                        // Only process if it's a chat message (not join message)\n                                        if (body.content && body.content !== \"joined\") {\n                                            // Create a unique key for message deduplication\n                                            const messageKey = \"\".concat(body.id || body.timestamp || Date.now(), \"_\").concat(body.senderId, \"_\").concat(body.content);\n                                            if (processedMessages.has(messageKey)) {\n                                                console.log(\"üì® Skipping duplicate message:\", messageKey);\n                                                return;\n                                            }\n                                            processedMessages.add(messageKey);\n                                            // Clean up old messages from the set (keep only last 100)\n                                            if (processedMessages.size > 100) {\n                                                const messagesArray = Array.from(processedMessages);\n                                                processedMessages.clear();\n                                                messagesArray.slice(-50).forEach({\n                                                    \"useChatSocket.useCallback[connect]\": (msg)=>processedMessages.add(msg)\n                                                }[\"useChatSocket.useCallback[connect]\"]);\n                                            }\n                                            console.log(\"üì® Processing private message\");\n                                            onMessageRef.current(body);\n                                        } else {\n                                            console.log(\"üì® Ignoring join message\");\n                                        }\n                                    } catch (error) {\n                                        console.error(\"‚ùå Error parsing private message:\", error);\n                                    }\n                                }\n                            }[\"useChatSocket.useCallback[connect]\"]);\n                            // Send join message only once per connection\n                            const joinMessage = {\n                                senderId: userId,\n                                senderName: userId,\n                                content: \"joined\",\n                                receiverId: \"\",\n                                listingId: \"\"\n                            };\n                            console.log(\"üëã Sending join message:\", joinMessage);\n                            client.publish({\n                                destination: \"/app/chat.join\",\n                                body: JSON.stringify(joinMessage)\n                            });\n                            (_onConnectRef_current = onConnectRef.current) === null || _onConnectRef_current === void 0 ? void 0 : _onConnectRef_current.call(onConnectRef);\n                        }\n                    }[\"useChatSocket.useCallback[connect]\"],\n                    onDisconnect: {\n                        \"useChatSocket.useCallback[connect]\": ()=>{\n                            var _onDisconnectRef_current;\n                            console.log(\"‚ùå WebSocket disconnected for user:\", userId);\n                            isConnectingRef.current = false;\n                            setConnectionState(\"disconnected\");\n                            // Remove from global manager\n                            connectionManager.delete(userId);\n                            clientRef.current = null;\n                            (_onDisconnectRef_current = onDisconnectRef.current) === null || _onDisconnectRef_current === void 0 ? void 0 : _onDisconnectRef_current.call(onDisconnectRef);\n                            // Attempt to reconnect if we haven't exceeded max attempts\n                            if (connectionAttemptsRef.current < maxReconnectAttempts) {\n                                connectionAttemptsRef.current++;\n                                console.log(\"\\uD83D\\uDD04 Reconnection attempt \".concat(connectionAttemptsRef.current, \"/\").concat(maxReconnectAttempts, \" for user:\"), userId);\n                                reconnectTimeoutRef.current = setTimeout({\n                                    \"useChatSocket.useCallback[connect]\": ()=>{\n                                        if (isInitializedRef.current) {\n                                            connect();\n                                        }\n                                    }\n                                }[\"useChatSocket.useCallback[connect]\"], reconnectDelay);\n                            } else {\n                                console.error(\"‚ùå Max reconnection attempts reached for user:\", userId);\n                                setConnectionState(\"error\");\n                            }\n                        }\n                    }[\"useChatSocket.useCallback[connect]\"],\n                    onStompError: {\n                        \"useChatSocket.useCallback[connect]\": (error)=>{\n                            console.error(\"‚ùå STOMP error for user\", userId, \":\", error);\n                            isConnectingRef.current = false;\n                            setConnectionState(\"error\");\n                        }\n                    }[\"useChatSocket.useCallback[connect]\"],\n                    onWebSocketError: {\n                        \"useChatSocket.useCallback[connect]\": (error)=>{\n                            console.error(\"‚ùå WebSocket error for user\", userId, \":\", error);\n                            isConnectingRef.current = false;\n                            setConnectionState(\"error\");\n                        }\n                    }[\"useChatSocket.useCallback[connect]\"],\n                    onWebSocketClose: {\n                        \"useChatSocket.useCallback[connect]\": ()=>{\n                            console.log(\"‚ùå WebSocket connection closed for user:\", userId);\n                            isConnectingRef.current = false;\n                            setConnectionState(\"disconnected\");\n                        }\n                    }[\"useChatSocket.useCallback[connect]\"]\n                });\n                client.activate();\n            } catch (error) {\n                console.error(\"‚ùå Error creating WebSocket connection for user\", userId, \":\", error);\n                isConnectingRef.current = false;\n                setConnectionState(\"error\");\n            }\n        }\n    }[\"useChatSocket.useCallback[connect]\"], [\n        userId,\n        cleanup\n    ]);\n    // Initialize connection when userId changes\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useChatSocket.useEffect\": ()=>{\n            if (userId) {\n                isInitializedRef.current = true;\n                connect();\n            } else {\n                cleanup();\n                isInitializedRef.current = false;\n                setConnectionState(\"disconnected\");\n            }\n            return ({\n                \"useChatSocket.useEffect\": ()=>{\n                    cleanup();\n                    isInitializedRef.current = false;\n                }\n            })[\"useChatSocket.useEffect\"];\n        }\n    }[\"useChatSocket.useEffect\"], [\n        userId,\n        connect,\n        cleanup\n    ]);\n    const sendMessage = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useChatSocket.useCallback[sendMessage]\": (msg)=>{\n            if (connectionState !== \"connected\" || !clientRef.current) {\n                console.error(\"‚ùå Cannot send message: not connected. State:\", connectionState);\n                return false;\n            }\n            try {\n                console.log(\"üì§ Sending private message via WebSocket:\", msg);\n                clientRef.current.publish({\n                    destination: \"/app/chat.private\",\n                    body: JSON.stringify(msg)\n                });\n                console.log(\"‚úÖ Private message sent successfully via WebSocket\");\n                return true;\n            } catch (error) {\n                console.error(\"‚ùå Error sending private message via WebSocket:\", error);\n                return false;\n            }\n        }\n    }[\"useChatSocket.useCallback[sendMessage]\"], [\n        connectionState\n    ]);\n    const isConnected = connectionState === \"connected\";\n    const isConnecting = connectionState === \"connecting\";\n    const hasError = connectionState === \"error\";\n    return {\n        sendMessage,\n        isConnected,\n        isConnecting,\n        hasError,\n        connectionStatus: connectionState,\n        reconnect: ()=>{\n            console.log(\"üîÑ Manual reconnect requested for user:\", userId);\n            connectionAttemptsRef.current = 0;\n            isInitializedRef.current = false;\n            isConnectingRef.current = false;\n            // Clean up existing connection\n            const existingClient = connectionManager.get(userId);\n            if (existingClient) {\n                try {\n                    existingClient.deactivate();\n                } catch (error) {\n                    console.warn(\"Error deactivating client during manual reconnect:\", error);\n                }\n                connectionManager.delete(userId);\n            }\n            connect();\n        }\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZUNoYXRTb2NrZXQudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQWlFO0FBQzlCO0FBQ0s7QUFleEMscUVBQXFFO0FBQ3JFLE1BQU1NLG9CQUFvQixJQUFJQztBQUU5QixrRkFBa0Y7QUFDbEYsTUFBTUMsb0JBQW9CLElBQUlDO0FBRXZCLFNBQVNDLGNBQ2RDLE1BQWMsRUFDZEMsU0FBcUMsRUFDckNDLFNBQXNCLEVBQ3RCQyxZQUF5QjtJQUV6QixNQUFNQyxZQUFZZCw2Q0FBTUEsQ0FBZ0I7SUFDeEMsTUFBTSxDQUFDZSxpQkFBaUJDLG1CQUFtQixHQUFHZiwrQ0FBUUEsQ0FBa0I7SUFDeEUsTUFBTWdCLHNCQUFzQmpCLDZDQUFNQSxDQUF3QjtJQUMxRCxNQUFNa0Isd0JBQXdCbEIsNkNBQU1BLENBQUM7SUFDckMsTUFBTW1CLHVCQUF1QjtJQUM3QixNQUFNQyxpQkFBaUI7SUFDdkIsTUFBTUMsbUJBQW1CckIsNkNBQU1BLENBQUM7SUFDaEMsTUFBTXNCLGVBQWV0Qiw2Q0FBTUEsQ0FBQ1c7SUFDNUIsTUFBTVksZUFBZXZCLDZDQUFNQSxDQUFDWTtJQUM1QixNQUFNWSxrQkFBa0J4Qiw2Q0FBTUEsQ0FBQ2E7SUFDL0IsTUFBTVksa0JBQWtCekIsNkNBQU1BLENBQUM7SUFFL0Isb0NBQW9DO0lBQ3BDRCxnREFBU0E7bUNBQUM7WUFDUnVCLGFBQWFJLE9BQU8sR0FBR2Y7UUFDekI7a0NBQUc7UUFBQ0E7S0FBVTtJQUVkWixnREFBU0E7bUNBQUM7WUFDUndCLGFBQWFHLE9BQU8sR0FBR2Q7UUFDekI7a0NBQUc7UUFBQ0E7S0FBVTtJQUVkYixnREFBU0E7bUNBQUM7WUFDUnlCLGdCQUFnQkUsT0FBTyxHQUFHYjtRQUM1QjtrQ0FBRztRQUFDQTtLQUFhO0lBRWpCLE1BQU1jLFVBQVV6QixrREFBV0E7OENBQUM7WUFDMUIsSUFBSWUsb0JBQW9CUyxPQUFPLEVBQUU7Z0JBQy9CRSxhQUFhWCxvQkFBb0JTLE9BQU87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QVFDLEdBQUcsQ0FBQyw2Q0FBNkNnQztnQkFDekRwRCxVQUFVWSxPQUFPLENBQUM2QyxPQUFPLENBQUM7b0JBQ3hCQyxhQUFhO29CQUNiekIsTUFBTUMsS0FBS3lCLFNBQVMsQ0FBQ1A7Z0JBQ3ZCO2dCQUNBakMsUUFBUUMsR0FBRyxDQUFDO2dCQUNaLE9BQU87WUFDVCxFQUFFLE9BQU9FLE9BQU87Z0JBQ2RILFFBQVFHLEtBQUssQ0FBQyxrREFBa0RBO2dCQUNoRSxPQUFPO1lBQ1Q7UUFDRjtpREFBRztRQUFDckI7S0FBZ0I7SUFFcEIsTUFBTWlFLGNBQWNqRSxvQkFBb0I7SUFDeEMsTUFBTWtFLGVBQWVsRSxvQkFBb0I7SUFDekMsTUFBTW1FLFdBQVduRSxvQkFBb0I7SUFFckMsT0FBTztRQUNMZ0U7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUMsa0JBQWtCcEU7UUFDbEJxRSxXQUFXO1lBQ1RuRCxRQUFRQyxHQUFHLENBQUMsMkNBQTJDeEI7WUFDdkRRLHNCQUFzQlEsT0FBTyxHQUFHO1lBQ2hDTCxpQkFBaUJLLE9BQU8sR0FBRztZQUMzQkQsZ0JBQWdCQyxPQUFPLEdBQUc7WUFFMUIsK0JBQStCO1lBQy9CLE1BQU1JLGlCQUFpQnpCLGtCQUFrQjBCLEdBQUcsQ0FBQ3JCO1lBQzdDLElBQUlvQixnQkFBZ0I7Z0JBQ2xCLElBQUk7b0JBQ0ZBLGVBQWVLLFVBQVU7Z0JBQzNCLEVBQUUsT0FBT0MsT0FBTztvQkFDZEgsUUFBUUksSUFBSSxDQUFDLHNEQUFzREQ7Z0JBQ3JFO2dCQUNBL0Isa0JBQWtCaUMsTUFBTSxDQUFDNUI7WUFDM0I7WUFFQW1CO1FBQ0Y7SUFDRjtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvbmloYWwvRGVza3RvcC9OaWhhbC9Qcm9qZWN0cy9saXN0cmkvYXBwcy9mcm9udGVuZC9ob29rcy91c2VDaGF0U29ja2V0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBTb2NrSlMgZnJvbSBcInNvY2tqcy1jbGllbnRcIjtcbmltcG9ydCB7IENsaWVudCB9IGZyb20gXCJAc3RvbXAvc3RvbXBqc1wiO1xuXG5leHBvcnQgdHlwZSBDaGF0TWVzc2FnZSA9IHtcbiAgaWQ/OiBzdHJpbmc7XG4gIGNvbnZlcnNhdGlvbklkPzogc3RyaW5nO1xuICBzZW5kZXJJZDogc3RyaW5nO1xuICBzZW5kZXJOYW1lOiBzdHJpbmc7XG4gIHJlY2VpdmVySWQ6IHN0cmluZztcbiAgY29udGVudDogc3RyaW5nO1xuICB0aW1lc3RhbXA/OiBzdHJpbmc7XG4gIGxpc3RpbmdJZDogc3RyaW5nO1xufTtcblxudHlwZSBDb25uZWN0aW9uU3RhdGUgPSBcImRpc2Nvbm5lY3RlZFwiIHwgXCJjb25uZWN0aW5nXCIgfCBcImNvbm5lY3RlZFwiIHwgXCJlcnJvclwiO1xuXG4vLyBHbG9iYWwgY29ubmVjdGlvbiBtYW5hZ2VyIHRvIHByZXZlbnQgbXVsdGlwbGUgY29ubmVjdGlvbnMgcGVyIHVzZXJcbmNvbnN0IGNvbm5lY3Rpb25NYW5hZ2VyID0gbmV3IE1hcDxzdHJpbmcsIENsaWVudD4oKTtcblxuLy8gTWVzc2FnZSBkZWR1cGxpY2F0aW9uIHNldCB0byBwcmV2ZW50IHByb2Nlc3NpbmcgdGhlIHNhbWUgbWVzc2FnZSBtdWx0aXBsZSB0aW1lc1xuY29uc3QgcHJvY2Vzc2VkTWVzc2FnZXMgPSBuZXcgU2V0PHN0cmluZz4oKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUNoYXRTb2NrZXQoXG4gIHVzZXJJZDogc3RyaW5nLFxuICBvbk1lc3NhZ2U6IChtc2c6IENoYXRNZXNzYWdlKSA9PiB2b2lkLFxuICBvbkNvbm5lY3Q/OiAoKSA9PiB2b2lkLFxuICBvbkRpc2Nvbm5lY3Q/OiAoKSA9PiB2b2lkXG4pIHtcbiAgY29uc3QgY2xpZW50UmVmID0gdXNlUmVmPENsaWVudCB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbY29ubmVjdGlvblN0YXRlLCBzZXRDb25uZWN0aW9uU3RhdGVdID0gdXNlU3RhdGU8Q29ubmVjdGlvblN0YXRlPihcImRpc2Nvbm5lY3RlZFwiKTtcbiAgY29uc3QgcmVjb25uZWN0VGltZW91dFJlZiA9IHVzZVJlZjxOb2RlSlMuVGltZW91dCB8IG51bGw+KG51bGwpO1xuICBjb25zdCBjb25uZWN0aW9uQXR0ZW1wdHNSZWYgPSB1c2VSZWYoMCk7XG4gIGNvbnN0IG1heFJlY29ubmVjdEF0dGVtcHRzID0gMztcbiAgY29uc3QgcmVjb25uZWN0RGVsYXkgPSAzMDAwO1xuICBjb25zdCBpc0luaXRpYWxpemVkUmVmID0gdXNlUmVmKGZhbHNlKTtcbiAgY29uc3Qgb25NZXNzYWdlUmVmID0gdXNlUmVmKG9uTWVzc2FnZSk7XG4gIGNvbnN0IG9uQ29ubmVjdFJlZiA9IHVzZVJlZihvbkNvbm5lY3QpO1xuICBjb25zdCBvbkRpc2Nvbm5lY3RSZWYgPSB1c2VSZWYob25EaXNjb25uZWN0KTtcbiAgY29uc3QgaXNDb25uZWN0aW5nUmVmID0gdXNlUmVmKGZhbHNlKTtcblxuICAvLyBVcGRhdGUgcmVmcyB3aGVuIGNhbGxiYWNrcyBjaGFuZ2VcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBvbk1lc3NhZ2VSZWYuY3VycmVudCA9IG9uTWVzc2FnZTtcbiAgfSwgW29uTWVzc2FnZV0pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgb25Db25uZWN0UmVmLmN1cnJlbnQgPSBvbkNvbm5lY3Q7XG4gIH0sIFtvbkNvbm5lY3RdKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIG9uRGlzY29ubmVjdFJlZi5jdXJyZW50ID0gb25EaXNjb25uZWN0O1xuICB9LCBbb25EaXNjb25uZWN0XSk7XG5cbiAgY29uc3QgY2xlYW51cCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAocmVjb25uZWN0VGltZW91dFJlZi5jdXJyZW50KSB7XG4gICAgICBjbGVhclRpbWVvdXQocmVjb25uZWN0VGltZW91dFJlZi5jdXJyZW50KTtcbiAgICAgIHJlY29ubmVjdFRpbWVvdXRSZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICB9LCBbXSk7XG5cbiAgY29uc3QgY29ubmVjdCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoIXVzZXJJZCB8fCBpc0Nvbm5lY3RpbmdSZWYuY3VycmVudCkgcmV0dXJuO1xuXG4gICAgLy8gQ2hlY2sgaWYgdGhlcmUncyBhbHJlYWR5IGEgY29ubmVjdGlvbiBmb3IgdGhpcyB1c2VyXG4gICAgY29uc3QgZXhpc3RpbmdDbGllbnQgPSBjb25uZWN0aW9uTWFuYWdlci5nZXQodXNlcklkKTtcbiAgICBpZiAoZXhpc3RpbmdDbGllbnQgJiYgZXhpc3RpbmdDbGllbnQuY29ubmVjdGVkKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIvCflIwgVXNpbmcgZXhpc3RpbmcgV2ViU29ja2V0IGNvbm5lY3Rpb24gZm9yIHVzZXI6XCIsIHVzZXJJZCk7XG4gICAgICBjbGllbnRSZWYuY3VycmVudCA9IGV4aXN0aW5nQ2xpZW50O1xuICAgICAgc2V0Q29ubmVjdGlvblN0YXRlKFwiY29ubmVjdGVkXCIpO1xuICAgICAgb25Db25uZWN0UmVmLmN1cnJlbnQ/LigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENsZWFuIHVwIGFueSBleGlzdGluZyBjb25uZWN0aW9uXG4gICAgaWYgKGV4aXN0aW5nQ2xpZW50KSB7XG4gICAgICB0cnkge1xuICAgICAgICBleGlzdGluZ0NsaWVudC5kZWFjdGl2YXRlKCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJFcnJvciBkZWFjdGl2YXRpbmcgZXhpc3RpbmcgY2xpZW50OlwiLCBlcnJvcik7XG4gICAgICB9XG4gICAgICBjb25uZWN0aW9uTWFuYWdlci5kZWxldGUodXNlcklkKTtcbiAgICB9XG5cbiAgICBjbGVhbnVwKCk7XG4gICAgY29ubmVjdGlvbkF0dGVtcHRzUmVmLmN1cnJlbnQgPSAwO1xuICAgIGlzQ29ubmVjdGluZ1JlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICBcbiAgICBjb25zb2xlLmxvZyhcIvCflIwgSW5pdGlhbGl6aW5nIG5ldyBXZWJTb2NrZXQgY29ubmVjdGlvbiBmb3IgdXNlcjpcIiwgdXNlcklkKTtcbiAgICBzZXRDb25uZWN0aW9uU3RhdGUoXCJjb25uZWN0aW5nXCIpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNvY2tldCA9IG5ldyBTb2NrSlMoXCJodHRwOi8vbG9jYWxob3N0OjgwODEvd3NcIik7XG4gICAgICBcbiAgICAgIGNvbnN0IGNsaWVudCA9IG5ldyBDbGllbnQoe1xuICAgICAgICB3ZWJTb2NrZXRGYWN0b3J5OiAoKSA9PiBzb2NrZXQsXG4gICAgICAgIHJlY29ubmVjdERlbGF5OiAwLCAvLyBEaXNhYmxlIGF1dG9tYXRpYyByZWNvbm5lY3Rpb25cbiAgICAgICAgaGVhcnRiZWF0SW5jb21pbmc6IDQwMDAsXG4gICAgICAgIGhlYXJ0YmVhdE91dGdvaW5nOiA0MDAwLFxuICAgICAgICBvbkNvbm5lY3Q6ICgpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIuKchSBXZWJTb2NrZXQgY29ubmVjdGVkIHN1Y2Nlc3NmdWxseSBmb3IgdXNlcjpcIiwgdXNlcklkKTtcbiAgICAgICAgICBjb25uZWN0aW9uQXR0ZW1wdHNSZWYuY3VycmVudCA9IDA7XG4gICAgICAgICAgaXNDb25uZWN0aW5nUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICBzZXRDb25uZWN0aW9uU3RhdGUoXCJjb25uZWN0ZWRcIik7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gU3RvcmUgdGhlIGNsaWVudCBpbiB0aGUgZ2xvYmFsIG1hbmFnZXJcbiAgICAgICAgICBjb25uZWN0aW9uTWFuYWdlci5zZXQodXNlcklkLCBjbGllbnQpO1xuICAgICAgICAgIGNsaWVudFJlZi5jdXJyZW50ID0gY2xpZW50O1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFN1YnNjcmliZSB0byB1c2VyLXNwZWNpZmljIHByaXZhdGUgbWVzc2FnZXNcbiAgICAgICAgICAvLyBUaGlzIGVuc3VyZXMgb25seSBtZXNzYWdlcyBpbnRlbmRlZCBmb3IgdGhpcyB1c2VyIGFyZSByZWNlaXZlZFxuICAgICAgICAgIGNsaWVudC5zdWJzY3JpYmUoYC91c2VyLyR7dXNlcklkfS9xdWV1ZS9tZXNzYWdlc2AsIChtZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIvCfk6ggUmVjZWl2ZWQgcHJpdmF0ZSBtZXNzYWdlIGZvciB1c2VyXCIsIHVzZXJJZCwgXCI6XCIsIG1lc3NhZ2UuYm9keSk7XG4gICAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnBhcnNlKG1lc3NhZ2UuYm9keSk7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi8J+TqCBQYXJzZWQgcHJpdmF0ZSBtZXNzYWdlOlwiLCBib2R5KTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIE9ubHkgcHJvY2VzcyBpZiBpdCdzIGEgY2hhdCBtZXNzYWdlIChub3Qgam9pbiBtZXNzYWdlKVxuICAgICAgICAgICAgICBpZiAoYm9keS5jb250ZW50ICYmIGJvZHkuY29udGVudCAhPT0gXCJqb2luZWRcIikge1xuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIHVuaXF1ZSBrZXkgZm9yIG1lc3NhZ2UgZGVkdXBsaWNhdGlvblxuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VLZXkgPSBgJHtib2R5LmlkIHx8IGJvZHkudGltZXN0YW1wIHx8IERhdGUubm93KCl9XyR7Ym9keS5zZW5kZXJJZH1fJHtib2R5LmNvbnRlbnR9YDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzc2VkTWVzc2FnZXMuaGFzKG1lc3NhZ2VLZXkpKSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIvCfk6ggU2tpcHBpbmcgZHVwbGljYXRlIG1lc3NhZ2U6XCIsIG1lc3NhZ2VLZXkpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBwcm9jZXNzZWRNZXNzYWdlcy5hZGQobWVzc2FnZUtleSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gQ2xlYW4gdXAgb2xkIG1lc3NhZ2VzIGZyb20gdGhlIHNldCAoa2VlcCBvbmx5IGxhc3QgMTAwKVxuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzZWRNZXNzYWdlcy5zaXplID4gMTAwKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlc0FycmF5ID0gQXJyYXkuZnJvbShwcm9jZXNzZWRNZXNzYWdlcyk7XG4gICAgICAgICAgICAgICAgICBwcm9jZXNzZWRNZXNzYWdlcy5jbGVhcigpO1xuICAgICAgICAgICAgICAgICAgbWVzc2FnZXNBcnJheS5zbGljZSgtNTApLmZvckVhY2gobXNnID0+IHByb2Nlc3NlZE1lc3NhZ2VzLmFkZChtc2cpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCLwn5OoIFByb2Nlc3NpbmcgcHJpdmF0ZSBtZXNzYWdlXCIpO1xuICAgICAgICAgICAgICAgIG9uTWVzc2FnZVJlZi5jdXJyZW50KGJvZHkpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi8J+TqCBJZ25vcmluZyBqb2luIG1lc3NhZ2VcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCLinYwgRXJyb3IgcGFyc2luZyBwcml2YXRlIG1lc3NhZ2U6XCIsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIFNlbmQgam9pbiBtZXNzYWdlIG9ubHkgb25jZSBwZXIgY29ubmVjdGlvblxuICAgICAgICAgIGNvbnN0IGpvaW5NZXNzYWdlID0ge1xuICAgICAgICAgICAgc2VuZGVySWQ6IHVzZXJJZCxcbiAgICAgICAgICAgIHNlbmRlck5hbWU6IHVzZXJJZCxcbiAgICAgICAgICAgIGNvbnRlbnQ6IFwiam9pbmVkXCIsXG4gICAgICAgICAgICByZWNlaXZlcklkOiBcIlwiLFxuICAgICAgICAgICAgbGlzdGluZ0lkOiBcIlwiXG4gICAgICAgICAgfTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIvCfkYsgU2VuZGluZyBqb2luIG1lc3NhZ2U6XCIsIGpvaW5NZXNzYWdlKTtcbiAgICAgICAgICBjbGllbnQucHVibGlzaCh7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbjogXCIvYXBwL2NoYXQuam9pblwiLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoam9pbk1lc3NhZ2UpLFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgb25Db25uZWN0UmVmLmN1cnJlbnQ/LigpO1xuICAgICAgICB9LFxuICAgICAgICBvbkRpc2Nvbm5lY3Q6ICgpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIuKdjCBXZWJTb2NrZXQgZGlzY29ubmVjdGVkIGZvciB1c2VyOlwiLCB1c2VySWQpO1xuICAgICAgICAgIGlzQ29ubmVjdGluZ1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgc2V0Q29ubmVjdGlvblN0YXRlKFwiZGlzY29ubmVjdGVkXCIpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFJlbW92ZSBmcm9tIGdsb2JhbCBtYW5hZ2VyXG4gICAgICAgICAgY29ubmVjdGlvbk1hbmFnZXIuZGVsZXRlKHVzZXJJZCk7XG4gICAgICAgICAgY2xpZW50UmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgIFxuICAgICAgICAgIG9uRGlzY29ubmVjdFJlZi5jdXJyZW50Py4oKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBBdHRlbXB0IHRvIHJlY29ubmVjdCBpZiB3ZSBoYXZlbid0IGV4Y2VlZGVkIG1heCBhdHRlbXB0c1xuICAgICAgICAgIGlmIChjb25uZWN0aW9uQXR0ZW1wdHNSZWYuY3VycmVudCA8IG1heFJlY29ubmVjdEF0dGVtcHRzKSB7XG4gICAgICAgICAgICBjb25uZWN0aW9uQXR0ZW1wdHNSZWYuY3VycmVudCsrO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYPCflIQgUmVjb25uZWN0aW9uIGF0dGVtcHQgJHtjb25uZWN0aW9uQXR0ZW1wdHNSZWYuY3VycmVudH0vJHttYXhSZWNvbm5lY3RBdHRlbXB0c30gZm9yIHVzZXI6YCwgdXNlcklkKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmVjb25uZWN0VGltZW91dFJlZi5jdXJyZW50ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChpc0luaXRpYWxpemVkUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBjb25uZWN0KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHJlY29ubmVjdERlbGF5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIuKdjCBNYXggcmVjb25uZWN0aW9uIGF0dGVtcHRzIHJlYWNoZWQgZm9yIHVzZXI6XCIsIHVzZXJJZCk7XG4gICAgICAgICAgICBzZXRDb25uZWN0aW9uU3RhdGUoXCJlcnJvclwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uU3RvbXBFcnJvcjogKGVycm9yKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIuKdjCBTVE9NUCBlcnJvciBmb3IgdXNlclwiLCB1c2VySWQsIFwiOlwiLCBlcnJvcik7XG4gICAgICAgICAgaXNDb25uZWN0aW5nUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICBzZXRDb25uZWN0aW9uU3RhdGUoXCJlcnJvclwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25XZWJTb2NrZXRFcnJvcjogKGVycm9yKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIuKdjCBXZWJTb2NrZXQgZXJyb3IgZm9yIHVzZXJcIiwgdXNlcklkLCBcIjpcIiwgZXJyb3IpO1xuICAgICAgICAgIGlzQ29ubmVjdGluZ1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgc2V0Q29ubmVjdGlvblN0YXRlKFwiZXJyb3JcIik7XG4gICAgICAgIH0sXG4gICAgICAgIG9uV2ViU29ja2V0Q2xvc2U6ICgpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIuKdjCBXZWJTb2NrZXQgY29ubmVjdGlvbiBjbG9zZWQgZm9yIHVzZXI6XCIsIHVzZXJJZCk7XG4gICAgICAgICAgaXNDb25uZWN0aW5nUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICBzZXRDb25uZWN0aW9uU3RhdGUoXCJkaXNjb25uZWN0ZWRcIik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBjbGllbnQuYWN0aXZhdGUoKTtcbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwi4p2MIEVycm9yIGNyZWF0aW5nIFdlYlNvY2tldCBjb25uZWN0aW9uIGZvciB1c2VyXCIsIHVzZXJJZCwgXCI6XCIsIGVycm9yKTtcbiAgICAgIGlzQ29ubmVjdGluZ1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICBzZXRDb25uZWN0aW9uU3RhdGUoXCJlcnJvclwiKTtcbiAgICB9XG4gIH0sIFt1c2VySWQsIGNsZWFudXBdKTtcblxuICAvLyBJbml0aWFsaXplIGNvbm5lY3Rpb24gd2hlbiB1c2VySWQgY2hhbmdlc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh1c2VySWQpIHtcbiAgICAgIGlzSW5pdGlhbGl6ZWRSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICBjb25uZWN0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsZWFudXAoKTtcbiAgICAgIGlzSW5pdGlhbGl6ZWRSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgc2V0Q29ubmVjdGlvblN0YXRlKFwiZGlzY29ubmVjdGVkXCIpO1xuICAgIH1cblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjbGVhbnVwKCk7XG4gICAgICBpc0luaXRpYWxpemVkUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9O1xuICB9LCBbdXNlcklkLCBjb25uZWN0LCBjbGVhbnVwXSk7XG5cbiAgY29uc3Qgc2VuZE1lc3NhZ2UgPSB1c2VDYWxsYmFjaygobXNnOiBDaGF0TWVzc2FnZSk6IGJvb2xlYW4gPT4ge1xuICAgIGlmIChjb25uZWN0aW9uU3RhdGUgIT09IFwiY29ubmVjdGVkXCIgfHwgIWNsaWVudFJlZi5jdXJyZW50KSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwi4p2MIENhbm5vdCBzZW5kIG1lc3NhZ2U6IG5vdCBjb25uZWN0ZWQuIFN0YXRlOlwiLCBjb25uZWN0aW9uU3RhdGUpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZyhcIvCfk6QgU2VuZGluZyBwcml2YXRlIG1lc3NhZ2UgdmlhIFdlYlNvY2tldDpcIiwgbXNnKTtcbiAgICAgIGNsaWVudFJlZi5jdXJyZW50LnB1Ymxpc2goe1xuICAgICAgICBkZXN0aW5hdGlvbjogXCIvYXBwL2NoYXQucHJpdmF0ZVwiLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShtc2cpLFxuICAgICAgfSk7XG4gICAgICBjb25zb2xlLmxvZyhcIuKchSBQcml2YXRlIG1lc3NhZ2Ugc2VudCBzdWNjZXNzZnVsbHkgdmlhIFdlYlNvY2tldFwiKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwi4p2MIEVycm9yIHNlbmRpbmcgcHJpdmF0ZSBtZXNzYWdlIHZpYSBXZWJTb2NrZXQ6XCIsIGVycm9yKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIFtjb25uZWN0aW9uU3RhdGVdKTtcblxuICBjb25zdCBpc0Nvbm5lY3RlZCA9IGNvbm5lY3Rpb25TdGF0ZSA9PT0gXCJjb25uZWN0ZWRcIjtcbiAgY29uc3QgaXNDb25uZWN0aW5nID0gY29ubmVjdGlvblN0YXRlID09PSBcImNvbm5lY3RpbmdcIjtcbiAgY29uc3QgaGFzRXJyb3IgPSBjb25uZWN0aW9uU3RhdGUgPT09IFwiZXJyb3JcIjtcblxuICByZXR1cm4ge1xuICAgIHNlbmRNZXNzYWdlLFxuICAgIGlzQ29ubmVjdGVkLFxuICAgIGlzQ29ubmVjdGluZyxcbiAgICBoYXNFcnJvcixcbiAgICBjb25uZWN0aW9uU3RhdHVzOiBjb25uZWN0aW9uU3RhdGUsXG4gICAgcmVjb25uZWN0OiAoKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZyhcIvCflIQgTWFudWFsIHJlY29ubmVjdCByZXF1ZXN0ZWQgZm9yIHVzZXI6XCIsIHVzZXJJZCk7XG4gICAgICBjb25uZWN0aW9uQXR0ZW1wdHNSZWYuY3VycmVudCA9IDA7XG4gICAgICBpc0luaXRpYWxpemVkUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgIGlzQ29ubmVjdGluZ1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICBcbiAgICAgIC8vIENsZWFuIHVwIGV4aXN0aW5nIGNvbm5lY3Rpb25cbiAgICAgIGNvbnN0IGV4aXN0aW5nQ2xpZW50ID0gY29ubmVjdGlvbk1hbmFnZXIuZ2V0KHVzZXJJZCk7XG4gICAgICBpZiAoZXhpc3RpbmdDbGllbnQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBleGlzdGluZ0NsaWVudC5kZWFjdGl2YXRlKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiRXJyb3IgZGVhY3RpdmF0aW5nIGNsaWVudCBkdXJpbmcgbWFudWFsIHJlY29ubmVjdDpcIiwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGNvbm5lY3Rpb25NYW5hZ2VyLmRlbGV0ZSh1c2VySWQpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25uZWN0KCk7XG4gICAgfVxuICB9O1xufVxuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZVN0YXRlIiwidXNlQ2FsbGJhY2siLCJTb2NrSlMiLCJDbGllbnQiLCJjb25uZWN0aW9uTWFuYWdlciIsIk1hcCIsInByb2Nlc3NlZE1lc3NhZ2VzIiwiU2V0IiwidXNlQ2hhdFNvY2tldCIsInVzZXJJZCIsIm9uTWVzc2FnZSIsIm9uQ29ubmVjdCIsIm9uRGlzY29ubmVjdCIsImNsaWVudFJlZiIsImNvbm5lY3Rpb25TdGF0ZSIsInNldENvbm5lY3Rpb25TdGF0ZSIsInJlY29ubmVjdFRpbWVvdXRSZWYiLCJjb25uZWN0aW9uQXR0ZW1wdHNSZWYiLCJtYXhSZWNvbm5lY3RBdHRlbXB0cyIsInJlY29ubmVjdERlbGF5IiwiaXNJbml0aWFsaXplZFJlZiIsIm9uTWVzc2FnZVJlZiIsIm9uQ29ubmVjdFJlZiIsIm9uRGlzY29ubmVjdFJlZiIsImlzQ29ubmVjdGluZ1JlZiIsImN1cnJlbnQiLCJjbGVhbnVwIiwiY2xlYXJUaW1lb3V0IiwiY29ubmVjdCIsImV4aXN0aW5nQ2xpZW50IiwiZ2V0IiwiY29ubmVjdGVkIiwiY29uc29sZSIsImxvZyIsImRlYWN0aXZhdGUiLCJlcnJvciIsIndhcm4iLCJkZWxldGUiLCJzb2NrZXQiLCJjbGllbnQiLCJ3ZWJTb2NrZXRGYWN0b3J5IiwiaGVhcnRiZWF0SW5jb21pbmciLCJoZWFydGJlYXRPdXRnb2luZyIsInNldCIsInN1YnNjcmliZSIsIm1lc3NhZ2UiLCJib2R5IiwiSlNPTiIsInBhcnNlIiwiY29udGVudCIsIm1lc3NhZ2VLZXkiLCJpZCIsInRpbWVzdGFtcCIsIkRhdGUiLCJub3ciLCJzZW5kZXJJZCIsImhhcyIsImFkZCIsInNpemUiLCJtZXNzYWdlc0FycmF5IiwiQXJyYXkiLCJmcm9tIiwiY2xlYXIiLCJzbGljZSIsImZvckVhY2giLCJtc2ciLCJqb2luTWVzc2FnZSIsInNlbmRlck5hbWUiLCJyZWNlaXZlcklkIiwibGlzdGluZ0lkIiwicHVibGlzaCIsImRlc3RpbmF0aW9uIiwic3RyaW5naWZ5Iiwic2V0VGltZW91dCIsIm9uU3RvbXBFcnJvciIsIm9uV2ViU29ja2V0RXJyb3IiLCJvbldlYlNvY2tldENsb3NlIiwiYWN0aXZhdGUiLCJzZW5kTWVzc2FnZSIsImlzQ29ubmVjdGVkIiwiaXNDb25uZWN0aW5nIiwiaGFzRXJyb3IiLCJjb25uZWN0aW9uU3RhdHVzIiwicmVjb25uZWN0Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/useChatSocket.ts\n"));

/***/ })

});