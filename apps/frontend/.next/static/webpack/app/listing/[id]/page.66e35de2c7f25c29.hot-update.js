"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/listing/[id]/page",{

/***/ "(app-pages-browser)/./src/contexts/ChatContext.tsx":
/*!**************************************!*\
  !*** ./src/contexts/ChatContext.tsx ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChatProvider: () => (/* binding */ ChatProvider),\n/* harmony export */   useChat: () => (/* binding */ useChat)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/../../node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/../../node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var sockjs_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! sockjs-client */ \"(app-pages-browser)/../../node_modules/sockjs-client/lib/entry.js\");\n/* harmony import */ var sockjs_client__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(sockjs_client__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _stomp_stompjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @stomp/stompjs */ \"(app-pages-browser)/../../node_modules/@stomp/stompjs/esm6/client.js\");\n/* __next_internal_client_entry_do_not_use__ ChatProvider,useChat auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\nconst ChatContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\n// Global connection manager\nlet globalClient = null;\nlet globalConnectionState = \"disconnected\";\nlet messageListeners = new Set();\nlet processedMessages = new Set();\nfunction ChatProvider(param) {\n    let { children, userId } = param;\n    _s();\n    const [messages, setMessages] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [connectionState, setConnectionState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"disconnected\");\n    const reconnectTimeoutRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const connectionAttemptsRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n    const maxReconnectAttempts = 3;\n    const reconnectDelay = 3000;\n    const isConnectingRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    const updateConnectionState = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"ChatProvider.useCallback[updateConnectionState]\": (newState)=>{\n            globalConnectionState = newState;\n            setConnectionState(newState);\n        }\n    }[\"ChatProvider.useCallback[updateConnectionState]\"], []);\n    const addMessageListener = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"ChatProvider.useCallback[addMessageListener]\": (listener)=>{\n            messageListeners.add(listener);\n            return ({\n                \"ChatProvider.useCallback[addMessageListener]\": ()=>{\n                    messageListeners.delete(listener);\n                }\n            })[\"ChatProvider.useCallback[addMessageListener]\"];\n        }\n    }[\"ChatProvider.useCallback[addMessageListener]\"], []);\n    const notifyMessageListeners = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"ChatProvider.useCallback[notifyMessageListeners]\": (msg)=>{\n            messageListeners.forEach({\n                \"ChatProvider.useCallback[notifyMessageListeners]\": (listener)=>{\n                    try {\n                        listener(msg);\n                    } catch (error) {\n                        console.error(\"Error in message listener:\", error);\n                    }\n                }\n            }[\"ChatProvider.useCallback[notifyMessageListeners]\"]);\n        }\n    }[\"ChatProvider.useCallback[notifyMessageListeners]\"], []);\n    const connect = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"ChatProvider.useCallback[connect]\": ()=>{\n            if (!userId || isConnectingRef.current) return;\n            // Check if there's already a global connection\n            if (globalClient && globalClient.connected) {\n                console.log(\"🔌 Using existing global WebSocket connection for user:\", userId);\n                updateConnectionState(\"connected\");\n                return;\n            }\n            // Clean up any existing connection\n            if (globalClient) {\n                try {\n                    globalClient.deactivate();\n                } catch (error) {\n                    console.warn(\"Error deactivating existing global client:\", error);\n                }\n                globalClient = null;\n            }\n            if (reconnectTimeoutRef.current) {\n                clearTimeout(reconnectTimeoutRef.current);\n                reconnectTimeoutRef.current = null;\n            }\n            connectionAttemptsRef.current = 0;\n            isConnectingRef.current = true;\n            console.log(\"🔌 Initializing global WebSocket connection for user:\", userId);\n            updateConnectionState(\"connecting\");\n            try {\n                const socket = new (sockjs_client__WEBPACK_IMPORTED_MODULE_2___default())(\"http://localhost:8081/ws\");\n                const client = new _stomp_stompjs__WEBPACK_IMPORTED_MODULE_3__.Client({\n                    webSocketFactory: {\n                        \"ChatProvider.useCallback[connect]\": ()=>socket\n                    }[\"ChatProvider.useCallback[connect]\"],\n                    reconnectDelay: 0,\n                    heartbeatIncoming: 4000,\n                    heartbeatOutgoing: 4000,\n                    onConnect: {\n                        \"ChatProvider.useCallback[connect]\": ()=>{\n                            console.log(\"✅ Global WebSocket connected successfully for user:\", userId);\n                            connectionAttemptsRef.current = 0;\n                            isConnectingRef.current = false;\n                            updateConnectionState(\"connected\");\n                            globalClient = client;\n                            // Subscribe to all conversation topics (for now, we'll listen to all)\n                            // In a real app, you'd subscribe only to conversations the user is part of\n                            client.subscribe(\"/topic/conversation/#\", {\n                                \"ChatProvider.useCallback[connect]\": (message)=>{\n                                    try {\n                                        console.log(\"📨 Received conversation message:\", message.body);\n                                        const body = JSON.parse(message.body);\n                                        console.log(\"📨 Parsed conversation message:\", body);\n                                        // Only process if it's a chat message (not join message)\n                                        if (body.content && body.content !== \"joined\") {\n                                            // Create a unique key for message deduplication\n                                            const messageKey = \"\".concat(body.id || body.timestamp || Date.now(), \"_\").concat(body.senderId, \"_\").concat(body.content);\n                                            if (processedMessages.has(messageKey)) {\n                                                console.log(\"📨 Skipping duplicate message:\", messageKey);\n                                                return;\n                                            }\n                                            processedMessages.add(messageKey);\n                                            // Clean up old messages from the set (keep only last 100)\n                                            if (processedMessages.size > 100) {\n                                                const messagesArray = Array.from(processedMessages);\n                                                processedMessages.clear();\n                                                messagesArray.slice(-50).forEach({\n                                                    \"ChatProvider.useCallback[connect]\": (msg)=>processedMessages.add(msg)\n                                                }[\"ChatProvider.useCallback[connect]\"]);\n                                            }\n                                            console.log(\"📨 Processing conversation message\");\n                                            setMessages({\n                                                \"ChatProvider.useCallback[connect]\": (prev)=>[\n                                                        ...prev,\n                                                        body\n                                                    ]\n                                            }[\"ChatProvider.useCallback[connect]\"]);\n                                            notifyMessageListeners(body);\n                                        } else {\n                                            console.log(\"📨 Ignoring join message\");\n                                        }\n                                    } catch (error) {\n                                        console.error(\"❌ Error parsing conversation message:\", error);\n                                    }\n                                }\n                            }[\"ChatProvider.useCallback[connect]\"]);\n                            // Send join message only once per connection\n                            const joinMessage = {\n                                senderId: userId,\n                                senderName: userId,\n                                content: \"joined\",\n                                receiverId: \"\",\n                                listingId: \"\"\n                            };\n                            console.log(\"👋 Sending join message:\", joinMessage);\n                            client.publish({\n                                destination: \"/app/chat.join\",\n                                body: JSON.stringify(joinMessage)\n                            });\n                        }\n                    }[\"ChatProvider.useCallback[connect]\"],\n                    onDisconnect: {\n                        \"ChatProvider.useCallback[connect]\": ()=>{\n                            console.log(\"❌ Global WebSocket disconnected for user:\", userId);\n                            isConnectingRef.current = false;\n                            updateConnectionState(\"disconnected\");\n                            globalClient = null;\n                            // Attempt to reconnect if we haven't exceeded max attempts\n                            if (connectionAttemptsRef.current < maxReconnectAttempts) {\n                                connectionAttemptsRef.current++;\n                                console.log(\"\\uD83D\\uDD04 Reconnection attempt \".concat(connectionAttemptsRef.current, \"/\").concat(maxReconnectAttempts, \" for user:\"), userId);\n                                reconnectTimeoutRef.current = setTimeout({\n                                    \"ChatProvider.useCallback[connect]\": ()=>{\n                                        connect();\n                                    }\n                                }[\"ChatProvider.useCallback[connect]\"], reconnectDelay);\n                            } else {\n                                console.error(\"❌ Max reconnection attempts reached for user:\", userId);\n                                updateConnectionState(\"error\");\n                            }\n                        }\n                    }[\"ChatProvider.useCallback[connect]\"],\n                    onStompError: {\n                        \"ChatProvider.useCallback[connect]\": (error)=>{\n                            console.error(\"❌ STOMP error for user\", userId, \":\", error);\n                            isConnectingRef.current = false;\n                            updateConnectionState(\"error\");\n                        }\n                    }[\"ChatProvider.useCallback[connect]\"],\n                    onWebSocketError: {\n                        \"ChatProvider.useCallback[connect]\": (error)=>{\n                            console.error(\"❌ WebSocket error for user\", userId, \":\", error);\n                            isConnectingRef.current = false;\n                            updateConnectionState(\"error\");\n                        }\n                    }[\"ChatProvider.useCallback[connect]\"],\n                    onWebSocketClose: {\n                        \"ChatProvider.useCallback[connect]\": ()=>{\n                            console.log(\"❌ Global WebSocket connection closed for user:\", userId);\n                            isConnectingRef.current = false;\n                            updateConnectionState(\"disconnected\");\n                        }\n                    }[\"ChatProvider.useCallback[connect]\"]\n                });\n                client.activate();\n            } catch (error) {\n                console.error(\"❌ Error creating global WebSocket connection for user\", userId, \":\", error);\n                isConnectingRef.current = false;\n                updateConnectionState(\"error\");\n            }\n        }\n    }[\"ChatProvider.useCallback[connect]\"], [\n        userId,\n        updateConnectionState,\n        notifyMessageListeners\n    ]);\n    const sendMessage = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"ChatProvider.useCallback[sendMessage]\": (msg)=>{\n            if (connectionState !== \"connected\" || !globalClient) {\n                console.error(\"❌ Cannot send message: not connected. State:\", connectionState);\n                return false;\n            }\n            try {\n                console.log(\"📤 Sending private message via global WebSocket:\", msg);\n                globalClient.publish({\n                    destination: \"/app/chat.private\",\n                    body: JSON.stringify(msg)\n                });\n                console.log(\"✅ Private message sent successfully via global WebSocket\");\n                return true;\n            } catch (error) {\n                console.error(\"❌ Error sending private message via global WebSocket:\", error);\n                return false;\n            }\n        }\n    }[\"ChatProvider.useCallback[sendMessage]\"], [\n        connectionState\n    ]);\n    const reconnect = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"ChatProvider.useCallback[reconnect]\": ()=>{\n            console.log(\"🔄 Manual reconnect requested for user:\", userId);\n            connectionAttemptsRef.current = 0;\n            isConnectingRef.current = false;\n            // Clean up existing connection\n            if (globalClient) {\n                try {\n                    globalClient.deactivate();\n                } catch (error) {\n                    console.warn(\"Error deactivating global client during manual reconnect:\", error);\n                }\n                globalClient = null;\n            }\n            if (reconnectTimeoutRef.current) {\n                clearTimeout(reconnectTimeoutRef.current);\n                reconnectTimeoutRef.current = null;\n            }\n            connect();\n        }\n    }[\"ChatProvider.useCallback[reconnect]\"], [\n        userId,\n        connect\n    ]);\n    // Initialize connection when userId changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ChatProvider.useEffect\": ()=>{\n            if (userId) {\n                connect();\n            } else {\n                updateConnectionState(\"disconnected\");\n            }\n            return ({\n                \"ChatProvider.useEffect\": ()=>{\n                    if (reconnectTimeoutRef.current) {\n                        clearTimeout(reconnectTimeoutRef.current);\n                    }\n                }\n            })[\"ChatProvider.useEffect\"];\n        }\n    }[\"ChatProvider.useEffect\"], [\n        userId,\n        connect,\n        updateConnectionState\n    ]);\n    const isConnected = connectionState === \"connected\";\n    const isConnecting = connectionState === \"connecting\";\n    const hasError = connectionState === \"error\";\n    const contextValue = {\n        messages,\n        sendMessage,\n        isConnected,\n        isConnecting,\n        hasError,\n        connectionStatus: connectionState,\n        reconnect,\n        addMessageListener\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ChatContext.Provider, {\n        value: contextValue,\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/nihal/Desktop/Nihal/Projects/listri/apps/frontend/src/contexts/ChatContext.tsx\",\n        lineNumber: 289,\n        columnNumber: 5\n    }, this);\n}\n_s(ChatProvider, \"4oKLfQnyD9prkbVAW9bL6EmZx5Q=\");\n_c = ChatProvider;\nfunction useChat() {\n    _s1();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(ChatContext);\n    if (!context) {\n        throw new Error(\"useChat must be used within a ChatProvider\");\n    }\n    return context;\n}\n_s1(useChat, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"ChatProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb250ZXh0cy9DaGF0Q29udGV4dC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUVtRztBQUNoRTtBQUNLO0FBMEJ4QyxNQUFNUyw0QkFBY1Isb0RBQWFBLENBQXlCO0FBRTFELDRCQUE0QjtBQUM1QixJQUFJUyxlQUE4QjtBQUNsQyxJQUFJQyx3QkFBeUM7QUFDN0MsSUFBSUMsbUJBQW9ELElBQUlDO0FBQzVELElBQUlDLG9CQUFvQixJQUFJRDtBQUVyQixTQUFTRSxhQUFhLEtBQW1FO1FBQW5FLEVBQUVDLFFBQVEsRUFBRUMsTUFBTSxFQUFpRCxHQUFuRTs7SUFDM0IsTUFBTSxDQUFDQyxVQUFVQyxZQUFZLEdBQUdmLCtDQUFRQSxDQUFnQixFQUFFO0lBQzFELE1BQU0sQ0FBQ2dCLGlCQUFpQkMsbUJBQW1CLEdBQUdqQiwrQ0FBUUEsQ0FBa0I7SUFDeEUsTUFBTWtCLHNCQUFzQmpCLDZDQUFNQSxDQUF3QjtJQUMxRCxNQUFNa0Isd0JBQXdCbEIsNkNBQU1BLENBQUM7SUFDckMsTUFBTW1CLHVCQUF1QjtJQUM3QixNQUFNQyxpQkFBaUI7SUFDdkIsTUFBTUMsa0JBQWtCckIsNkNBQU1BLENBQUM7SUFFL0IsTUFBTXNCLHdCQUF3QnJCLGtEQUFXQTsyREFBQyxDQUFDc0I7WUFDekNqQix3QkFBd0JpQjtZQUN4QlAsbUJBQW1CTztRQUNyQjswREFBRyxFQUFFO0lBRUwsTUFBTUMscUJBQXFCdkIsa0RBQVdBO3dEQUFDLENBQUN3QjtZQUN0Q2xCLGlCQUFpQm1CLEdBQUcsQ0FBQ0Q7WUFDckI7Z0VBQU87b0JBQ0xsQixpQkFBaUJvQixNQUFNLENBQUNGO2dCQUMxQjs7UUFDRjt1REFBRyxFQUFFO0lBRUwsTUFBTUcseUJBQXlCM0Isa0RBQVdBOzREQUFDLENBQUM0QjtZQUMxQ3RCLGlCQUFpQnVCLE9BQU87b0VBQUNMLENBQUFBO29CQUN2QixJQUFJO3dCQUNGQSxTQUFTSTtvQkFDWCxFQUFFLE9BQU9FLE9B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RUFBRTtnQkFDL0JLLGFBQWF0QixvQkFBb0JpQixPQUFPO2dCQUN4Q2pCLG9CQUFvQmlCLE9BQU8sR0FBRztZQUNoQztZQUVBRDtRQUNGOzhDQUFHO1FBQUNyQjtRQUFRcUI7S0FBUTtJQUVwQiw0Q0FBNEM7SUFDNUNuQyxnREFBU0E7a0NBQUM7WUFDUixJQUFJYyxRQUFRO2dCQUNWcUI7WUFDRixPQUFPO2dCQUNMWCxzQkFBc0I7WUFDeEI7WUFFQTswQ0FBTztvQkFDTCxJQUFJTCxvQkFBb0JpQixPQUFPLEVBQUU7d0JBQy9CSyxhQUFhdEIsb0JBQW9CaUIsT0FBTztvQkFDMUM7Z0JBQ0Y7O1FBQ0Y7aUNBQUc7UUFBQ3RCO1FBQVFxQjtRQUFTWDtLQUFzQjtJQUUzQyxNQUFNMkQsY0FBY2xFLG9CQUFvQjtJQUN4QyxNQUFNbUUsZUFBZW5FLG9CQUFvQjtJQUN6QyxNQUFNb0UsV0FBV3BFLG9CQUFvQjtJQUVyQyxNQUFNcUUsZUFBZ0M7UUFDcEN2RTtRQUNBa0U7UUFDQUU7UUFDQUM7UUFDQUM7UUFDQUUsa0JBQWtCdEU7UUFDbEJpRTtRQUNBeEQ7SUFDRjtJQUVBLHFCQUNFLDhEQUFDcEIsWUFBWWtGLFFBQVE7UUFBQ0MsT0FBT0g7a0JBQzFCekU7Ozs7OztBQUdQO0dBOVBnQkQ7S0FBQUE7QUFnUVQsU0FBUzhFOztJQUNkLE1BQU1DLFVBQVU1RixpREFBVUEsQ0FBQ087SUFDM0IsSUFBSSxDQUFDcUYsU0FBUztRQUNaLE1BQU0sSUFBSUMsTUFBTTtJQUNsQjtJQUNBLE9BQU9EO0FBQ1Q7SUFOZ0JEIiwic291cmNlcyI6WyIvVXNlcnMvbmloYWwvRGVza3RvcC9OaWhhbC9Qcm9qZWN0cy9saXN0cmkvYXBwcy9mcm9udGVuZC9zcmMvY29udGV4dHMvQ2hhdENvbnRleHQudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXG5pbXBvcnQgUmVhY3QsIHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlRWZmZWN0LCB1c2VTdGF0ZSwgdXNlUmVmLCB1c2VDYWxsYmFjayB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IFNvY2tKUyBmcm9tIFwic29ja2pzLWNsaWVudFwiO1xuaW1wb3J0IHsgQ2xpZW50IH0gZnJvbSBcIkBzdG9tcC9zdG9tcGpzXCI7XG5cbmV4cG9ydCB0eXBlIENoYXRNZXNzYWdlID0ge1xuICBpZD86IHN0cmluZztcbiAgY29udmVyc2F0aW9uSWQ/OiBzdHJpbmc7XG4gIHNlbmRlcklkOiBzdHJpbmc7XG4gIHNlbmRlck5hbWU6IHN0cmluZztcbiAgcmVjZWl2ZXJJZDogc3RyaW5nO1xuICBjb250ZW50OiBzdHJpbmc7XG4gIHRpbWVzdGFtcD86IHN0cmluZztcbiAgbGlzdGluZ0lkOiBzdHJpbmc7XG59O1xuXG50eXBlIENvbm5lY3Rpb25TdGF0ZSA9IFwiZGlzY29ubmVjdGVkXCIgfCBcImNvbm5lY3RpbmdcIiB8IFwiY29ubmVjdGVkXCIgfCBcImVycm9yXCI7XG5cbmludGVyZmFjZSBDaGF0Q29udGV4dFR5cGUge1xuICBtZXNzYWdlczogQ2hhdE1lc3NhZ2VbXTtcbiAgc2VuZE1lc3NhZ2U6IChtc2c6IENoYXRNZXNzYWdlKSA9PiBib29sZWFuO1xuICBpc0Nvbm5lY3RlZDogYm9vbGVhbjtcbiAgaXNDb25uZWN0aW5nOiBib29sZWFuO1xuICBoYXNFcnJvcjogYm9vbGVhbjtcbiAgY29ubmVjdGlvblN0YXR1czogQ29ubmVjdGlvblN0YXRlO1xuICByZWNvbm5lY3Q6ICgpID0+IHZvaWQ7XG4gIGFkZE1lc3NhZ2VMaXN0ZW5lcjogKGxpc3RlbmVyOiAobXNnOiBDaGF0TWVzc2FnZSkgPT4gdm9pZCkgPT4gKCkgPT4gdm9pZDtcbn1cblxuY29uc3QgQ2hhdENvbnRleHQgPSBjcmVhdGVDb250ZXh0PENoYXRDb250ZXh0VHlwZSB8IG51bGw+KG51bGwpO1xuXG4vLyBHbG9iYWwgY29ubmVjdGlvbiBtYW5hZ2VyXG5sZXQgZ2xvYmFsQ2xpZW50OiBDbGllbnQgfCBudWxsID0gbnVsbDtcbmxldCBnbG9iYWxDb25uZWN0aW9uU3RhdGU6IENvbm5lY3Rpb25TdGF0ZSA9IFwiZGlzY29ubmVjdGVkXCI7XG5sZXQgbWVzc2FnZUxpc3RlbmVyczogU2V0PChtc2c6IENoYXRNZXNzYWdlKSA9PiB2b2lkPiA9IG5ldyBTZXQoKTtcbmxldCBwcm9jZXNzZWRNZXNzYWdlcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXG5leHBvcnQgZnVuY3Rpb24gQ2hhdFByb3ZpZGVyKHsgY2hpbGRyZW4sIHVzZXJJZCB9OiB7IGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGU7IHVzZXJJZDogc3RyaW5nIH0pIHtcbiAgY29uc3QgW21lc3NhZ2VzLCBzZXRNZXNzYWdlc10gPSB1c2VTdGF0ZTxDaGF0TWVzc2FnZVtdPihbXSk7XG4gIGNvbnN0IFtjb25uZWN0aW9uU3RhdGUsIHNldENvbm5lY3Rpb25TdGF0ZV0gPSB1c2VTdGF0ZTxDb25uZWN0aW9uU3RhdGU+KFwiZGlzY29ubmVjdGVkXCIpO1xuICBjb25zdCByZWNvbm5lY3RUaW1lb3V0UmVmID0gdXNlUmVmPE5vZGVKUy5UaW1lb3V0IHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IGNvbm5lY3Rpb25BdHRlbXB0c1JlZiA9IHVzZVJlZigwKTtcbiAgY29uc3QgbWF4UmVjb25uZWN0QXR0ZW1wdHMgPSAzO1xuICBjb25zdCByZWNvbm5lY3REZWxheSA9IDMwMDA7XG4gIGNvbnN0IGlzQ29ubmVjdGluZ1JlZiA9IHVzZVJlZihmYWxzZSk7XG5cbiAgY29uc3QgdXBkYXRlQ29ubmVjdGlvblN0YXRlID0gdXNlQ2FsbGJhY2soKG5ld1N0YXRlOiBDb25uZWN0aW9uU3RhdGUpID0+IHtcbiAgICBnbG9iYWxDb25uZWN0aW9uU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICBzZXRDb25uZWN0aW9uU3RhdGUobmV3U3RhdGUpO1xuICB9LCBbXSk7XG5cbiAgY29uc3QgYWRkTWVzc2FnZUxpc3RlbmVyID0gdXNlQ2FsbGJhY2soKGxpc3RlbmVyOiAobXNnOiBDaGF0TWVzc2FnZSkgPT4gdm9pZCkgPT4ge1xuICAgIG1lc3NhZ2VMaXN0ZW5lcnMuYWRkKGxpc3RlbmVyKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgbWVzc2FnZUxpc3RlbmVycy5kZWxldGUobGlzdGVuZXIpO1xuICAgIH07XG4gIH0sIFtdKTtcblxuICBjb25zdCBub3RpZnlNZXNzYWdlTGlzdGVuZXJzID0gdXNlQ2FsbGJhY2soKG1zZzogQ2hhdE1lc3NhZ2UpID0+IHtcbiAgICBtZXNzYWdlTGlzdGVuZXJzLmZvckVhY2gobGlzdGVuZXIgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGlzdGVuZXIobXNnKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBpbiBtZXNzYWdlIGxpc3RlbmVyOlwiLCBlcnJvcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sIFtdKTtcblxuICBjb25zdCBjb25uZWN0ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmICghdXNlcklkIHx8IGlzQ29ubmVjdGluZ1JlZi5jdXJyZW50KSByZXR1cm47XG5cbiAgICAvLyBDaGVjayBpZiB0aGVyZSdzIGFscmVhZHkgYSBnbG9iYWwgY29ubmVjdGlvblxuICAgIGlmIChnbG9iYWxDbGllbnQgJiYgZ2xvYmFsQ2xpZW50LmNvbm5lY3RlZCkge1xuICAgICAgY29uc29sZS5sb2coXCLwn5SMIFVzaW5nIGV4aXN0aW5nIGdsb2JhbCBXZWJTb2NrZXQgY29ubmVjdGlvbiBmb3IgdXNlcjpcIiwgdXNlcklkKTtcbiAgICAgIHVwZGF0ZUNvbm5lY3Rpb25TdGF0ZShcImNvbm5lY3RlZFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDbGVhbiB1cCBhbnkgZXhpc3RpbmcgY29ubmVjdGlvblxuICAgIGlmIChnbG9iYWxDbGllbnQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGdsb2JhbENsaWVudC5kZWFjdGl2YXRlKCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJFcnJvciBkZWFjdGl2YXRpbmcgZXhpc3RpbmcgZ2xvYmFsIGNsaWVudDpcIiwgZXJyb3IpO1xuICAgICAgfVxuICAgICAgZ2xvYmFsQ2xpZW50ID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAocmVjb25uZWN0VGltZW91dFJlZi5jdXJyZW50KSB7XG4gICAgICBjbGVhclRpbWVvdXQocmVjb25uZWN0VGltZW91dFJlZi5jdXJyZW50KTtcbiAgICAgIHJlY29ubmVjdFRpbWVvdXRSZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxuXG4gICAgY29ubmVjdGlvbkF0dGVtcHRzUmVmLmN1cnJlbnQgPSAwO1xuICAgIGlzQ29ubmVjdGluZ1JlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICBcbiAgICBjb25zb2xlLmxvZyhcIvCflIwgSW5pdGlhbGl6aW5nIGdsb2JhbCBXZWJTb2NrZXQgY29ubmVjdGlvbiBmb3IgdXNlcjpcIiwgdXNlcklkKTtcbiAgICB1cGRhdGVDb25uZWN0aW9uU3RhdGUoXCJjb25uZWN0aW5nXCIpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNvY2tldCA9IG5ldyBTb2NrSlMoXCJodHRwOi8vbG9jYWxob3N0OjgwODEvd3NcIik7XG4gICAgICBcbiAgICAgIGNvbnN0IGNsaWVudCA9IG5ldyBDbGllbnQoe1xuICAgICAgICB3ZWJTb2NrZXRGYWN0b3J5OiAoKSA9PiBzb2NrZXQsXG4gICAgICAgIHJlY29ubmVjdERlbGF5OiAwLCAvLyBEaXNhYmxlIGF1dG9tYXRpYyByZWNvbm5lY3Rpb25cbiAgICAgICAgaGVhcnRiZWF0SW5jb21pbmc6IDQwMDAsXG4gICAgICAgIGhlYXJ0YmVhdE91dGdvaW5nOiA0MDAwLFxuICAgICAgICBvbkNvbm5lY3Q6ICgpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIuKchSBHbG9iYWwgV2ViU29ja2V0IGNvbm5lY3RlZCBzdWNjZXNzZnVsbHkgZm9yIHVzZXI6XCIsIHVzZXJJZCk7XG4gICAgICAgICAgY29ubmVjdGlvbkF0dGVtcHRzUmVmLmN1cnJlbnQgPSAwO1xuICAgICAgICAgIGlzQ29ubmVjdGluZ1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgdXBkYXRlQ29ubmVjdGlvblN0YXRlKFwiY29ubmVjdGVkXCIpO1xuICAgICAgICAgIFxuICAgICAgICAgIGdsb2JhbENsaWVudCA9IGNsaWVudDtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBTdWJzY3JpYmUgdG8gYWxsIGNvbnZlcnNhdGlvbiB0b3BpY3MgKGZvciBub3csIHdlJ2xsIGxpc3RlbiB0byBhbGwpXG4gICAgICAgICAgLy8gSW4gYSByZWFsIGFwcCwgeW91J2Qgc3Vic2NyaWJlIG9ubHkgdG8gY29udmVyc2F0aW9ucyB0aGUgdXNlciBpcyBwYXJ0IG9mXG4gICAgICAgICAgY2xpZW50LnN1YnNjcmliZShcIi90b3BpYy9jb252ZXJzYXRpb24vI1wiLCAobWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXCLwn5OoIFJlY2VpdmVkIGNvbnZlcnNhdGlvbiBtZXNzYWdlOlwiLCBtZXNzYWdlLmJvZHkpO1xuICAgICAgICAgICAgICBjb25zdCBib2R5ID0gSlNPTi5wYXJzZShtZXNzYWdlLmJvZHkpO1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIvCfk6ggUGFyc2VkIGNvbnZlcnNhdGlvbiBtZXNzYWdlOlwiLCBib2R5KTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIE9ubHkgcHJvY2VzcyBpZiBpdCdzIGEgY2hhdCBtZXNzYWdlIChub3Qgam9pbiBtZXNzYWdlKVxuICAgICAgICAgICAgICBpZiAoYm9keS5jb250ZW50ICYmIGJvZHkuY29udGVudCAhPT0gXCJqb2luZWRcIikge1xuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIHVuaXF1ZSBrZXkgZm9yIG1lc3NhZ2UgZGVkdXBsaWNhdGlvblxuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VLZXkgPSBgJHtib2R5LmlkIHx8IGJvZHkudGltZXN0YW1wIHx8IERhdGUubm93KCl9XyR7Ym9keS5zZW5kZXJJZH1fJHtib2R5LmNvbnRlbnR9YDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzc2VkTWVzc2FnZXMuaGFzKG1lc3NhZ2VLZXkpKSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIvCfk6ggU2tpcHBpbmcgZHVwbGljYXRlIG1lc3NhZ2U6XCIsIG1lc3NhZ2VLZXkpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBwcm9jZXNzZWRNZXNzYWdlcy5hZGQobWVzc2FnZUtleSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gQ2xlYW4gdXAgb2xkIG1lc3NhZ2VzIGZyb20gdGhlIHNldCAoa2VlcCBvbmx5IGxhc3QgMTAwKVxuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzZWRNZXNzYWdlcy5zaXplID4gMTAwKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlc0FycmF5ID0gQXJyYXkuZnJvbShwcm9jZXNzZWRNZXNzYWdlcyk7XG4gICAgICAgICAgICAgICAgICBwcm9jZXNzZWRNZXNzYWdlcy5jbGVhcigpO1xuICAgICAgICAgICAgICAgICAgbWVzc2FnZXNBcnJheS5zbGljZSgtNTApLmZvckVhY2gobXNnID0+IHByb2Nlc3NlZE1lc3NhZ2VzLmFkZChtc2cpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCLwn5OoIFByb2Nlc3NpbmcgY29udmVyc2F0aW9uIG1lc3NhZ2VcIik7XG4gICAgICAgICAgICAgICAgc2V0TWVzc2FnZXMocHJldiA9PiBbLi4ucHJldiwgYm9keV0pO1xuICAgICAgICAgICAgICAgIG5vdGlmeU1lc3NhZ2VMaXN0ZW5lcnMoYm9keSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCLwn5OoIElnbm9yaW5nIGpvaW4gbWVzc2FnZVwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIuKdjCBFcnJvciBwYXJzaW5nIGNvbnZlcnNhdGlvbiBtZXNzYWdlOlwiLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBTZW5kIGpvaW4gbWVzc2FnZSBvbmx5IG9uY2UgcGVyIGNvbm5lY3Rpb25cbiAgICAgICAgICBjb25zdCBqb2luTWVzc2FnZSA9IHtcbiAgICAgICAgICAgIHNlbmRlcklkOiB1c2VySWQsXG4gICAgICAgICAgICBzZW5kZXJOYW1lOiB1c2VySWQsXG4gICAgICAgICAgICBjb250ZW50OiBcImpvaW5lZFwiLFxuICAgICAgICAgICAgcmVjZWl2ZXJJZDogXCJcIixcbiAgICAgICAgICAgIGxpc3RpbmdJZDogXCJcIlxuICAgICAgICAgIH07XG4gICAgICAgICAgY29uc29sZS5sb2coXCLwn5GLIFNlbmRpbmcgam9pbiBtZXNzYWdlOlwiLCBqb2luTWVzc2FnZSk7XG4gICAgICAgICAgY2xpZW50LnB1Ymxpc2goe1xuICAgICAgICAgICAgZGVzdGluYXRpb246IFwiL2FwcC9jaGF0LmpvaW5cIixcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGpvaW5NZXNzYWdlKSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25EaXNjb25uZWN0OiAoKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCLinYwgR2xvYmFsIFdlYlNvY2tldCBkaXNjb25uZWN0ZWQgZm9yIHVzZXI6XCIsIHVzZXJJZCk7XG4gICAgICAgICAgaXNDb25uZWN0aW5nUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICB1cGRhdGVDb25uZWN0aW9uU3RhdGUoXCJkaXNjb25uZWN0ZWRcIik7XG4gICAgICAgICAgXG4gICAgICAgICAgZ2xvYmFsQ2xpZW50ID0gbnVsbDtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBBdHRlbXB0IHRvIHJlY29ubmVjdCBpZiB3ZSBoYXZlbid0IGV4Y2VlZGVkIG1heCBhdHRlbXB0c1xuICAgICAgICAgIGlmIChjb25uZWN0aW9uQXR0ZW1wdHNSZWYuY3VycmVudCA8IG1heFJlY29ubmVjdEF0dGVtcHRzKSB7XG4gICAgICAgICAgICBjb25uZWN0aW9uQXR0ZW1wdHNSZWYuY3VycmVudCsrO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYPCflIQgUmVjb25uZWN0aW9uIGF0dGVtcHQgJHtjb25uZWN0aW9uQXR0ZW1wdHNSZWYuY3VycmVudH0vJHttYXhSZWNvbm5lY3RBdHRlbXB0c30gZm9yIHVzZXI6YCwgdXNlcklkKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmVjb25uZWN0VGltZW91dFJlZi5jdXJyZW50ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIGNvbm5lY3QoKTtcbiAgICAgICAgICAgIH0sIHJlY29ubmVjdERlbGF5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIuKdjCBNYXggcmVjb25uZWN0aW9uIGF0dGVtcHRzIHJlYWNoZWQgZm9yIHVzZXI6XCIsIHVzZXJJZCk7XG4gICAgICAgICAgICB1cGRhdGVDb25uZWN0aW9uU3RhdGUoXCJlcnJvclwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uU3RvbXBFcnJvcjogKGVycm9yKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIuKdjCBTVE9NUCBlcnJvciBmb3IgdXNlclwiLCB1c2VySWQsIFwiOlwiLCBlcnJvcik7XG4gICAgICAgICAgaXNDb25uZWN0aW5nUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICB1cGRhdGVDb25uZWN0aW9uU3RhdGUoXCJlcnJvclwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25XZWJTb2NrZXRFcnJvcjogKGVycm9yKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIuKdjCBXZWJTb2NrZXQgZXJyb3IgZm9yIHVzZXJcIiwgdXNlcklkLCBcIjpcIiwgZXJyb3IpO1xuICAgICAgICAgIGlzQ29ubmVjdGluZ1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgdXBkYXRlQ29ubmVjdGlvblN0YXRlKFwiZXJyb3JcIik7XG4gICAgICAgIH0sXG4gICAgICAgIG9uV2ViU29ja2V0Q2xvc2U6ICgpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIuKdjCBHbG9iYWwgV2ViU29ja2V0IGNvbm5lY3Rpb24gY2xvc2VkIGZvciB1c2VyOlwiLCB1c2VySWQpO1xuICAgICAgICAgIGlzQ29ubmVjdGluZ1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgdXBkYXRlQ29ubmVjdGlvblN0YXRlKFwiZGlzY29ubmVjdGVkXCIpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgY2xpZW50LmFjdGl2YXRlKCk7XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIuKdjCBFcnJvciBjcmVhdGluZyBnbG9iYWwgV2ViU29ja2V0IGNvbm5lY3Rpb24gZm9yIHVzZXJcIiwgdXNlcklkLCBcIjpcIiwgZXJyb3IpO1xuICAgICAgaXNDb25uZWN0aW5nUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgIHVwZGF0ZUNvbm5lY3Rpb25TdGF0ZShcImVycm9yXCIpO1xuICAgIH1cbiAgfSwgW3VzZXJJZCwgdXBkYXRlQ29ubmVjdGlvblN0YXRlLCBub3RpZnlNZXNzYWdlTGlzdGVuZXJzXSk7XG5cbiAgY29uc3Qgc2VuZE1lc3NhZ2UgPSB1c2VDYWxsYmFjaygobXNnOiBDaGF0TWVzc2FnZSk6IGJvb2xlYW4gPT4ge1xuICAgIGlmIChjb25uZWN0aW9uU3RhdGUgIT09IFwiY29ubmVjdGVkXCIgfHwgIWdsb2JhbENsaWVudCkge1xuICAgICAgY29uc29sZS5lcnJvcihcIuKdjCBDYW5ub3Qgc2VuZCBtZXNzYWdlOiBub3QgY29ubmVjdGVkLiBTdGF0ZTpcIiwgY29ubmVjdGlvblN0YXRlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coXCLwn5OkIFNlbmRpbmcgcHJpdmF0ZSBtZXNzYWdlIHZpYSBnbG9iYWwgV2ViU29ja2V0OlwiLCBtc2cpO1xuICAgICAgZ2xvYmFsQ2xpZW50LnB1Ymxpc2goe1xuICAgICAgICBkZXN0aW5hdGlvbjogXCIvYXBwL2NoYXQucHJpdmF0ZVwiLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShtc2cpLFxuICAgICAgfSk7XG4gICAgICBjb25zb2xlLmxvZyhcIuKchSBQcml2YXRlIG1lc3NhZ2Ugc2VudCBzdWNjZXNzZnVsbHkgdmlhIGdsb2JhbCBXZWJTb2NrZXRcIik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIuKdjCBFcnJvciBzZW5kaW5nIHByaXZhdGUgbWVzc2FnZSB2aWEgZ2xvYmFsIFdlYlNvY2tldDpcIiwgZXJyb3IpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwgW2Nvbm5lY3Rpb25TdGF0ZV0pO1xuXG4gIGNvbnN0IHJlY29ubmVjdCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjb25zb2xlLmxvZyhcIvCflIQgTWFudWFsIHJlY29ubmVjdCByZXF1ZXN0ZWQgZm9yIHVzZXI6XCIsIHVzZXJJZCk7XG4gICAgY29ubmVjdGlvbkF0dGVtcHRzUmVmLmN1cnJlbnQgPSAwO1xuICAgIGlzQ29ubmVjdGluZ1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgXG4gICAgLy8gQ2xlYW4gdXAgZXhpc3RpbmcgY29ubmVjdGlvblxuICAgIGlmIChnbG9iYWxDbGllbnQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGdsb2JhbENsaWVudC5kZWFjdGl2YXRlKCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJFcnJvciBkZWFjdGl2YXRpbmcgZ2xvYmFsIGNsaWVudCBkdXJpbmcgbWFudWFsIHJlY29ubmVjdDpcIiwgZXJyb3IpO1xuICAgICAgfVxuICAgICAgZ2xvYmFsQ2xpZW50ID0gbnVsbDtcbiAgICB9XG4gICAgXG4gICAgaWYgKHJlY29ubmVjdFRpbWVvdXRSZWYuY3VycmVudCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHJlY29ubmVjdFRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgICByZWNvbm5lY3RUaW1lb3V0UmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgICBcbiAgICBjb25uZWN0KCk7XG4gIH0sIFt1c2VySWQsIGNvbm5lY3RdKTtcblxuICAvLyBJbml0aWFsaXplIGNvbm5lY3Rpb24gd2hlbiB1c2VySWQgY2hhbmdlc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh1c2VySWQpIHtcbiAgICAgIGNvbm5lY3QoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdXBkYXRlQ29ubmVjdGlvblN0YXRlKFwiZGlzY29ubmVjdGVkXCIpO1xuICAgIH1cblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAocmVjb25uZWN0VGltZW91dFJlZi5jdXJyZW50KSB7XG4gICAgICAgIGNsZWFyVGltZW91dChyZWNvbm5lY3RUaW1lb3V0UmVmLmN1cnJlbnQpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFt1c2VySWQsIGNvbm5lY3QsIHVwZGF0ZUNvbm5lY3Rpb25TdGF0ZV0pO1xuXG4gIGNvbnN0IGlzQ29ubmVjdGVkID0gY29ubmVjdGlvblN0YXRlID09PSBcImNvbm5lY3RlZFwiO1xuICBjb25zdCBpc0Nvbm5lY3RpbmcgPSBjb25uZWN0aW9uU3RhdGUgPT09IFwiY29ubmVjdGluZ1wiO1xuICBjb25zdCBoYXNFcnJvciA9IGNvbm5lY3Rpb25TdGF0ZSA9PT0gXCJlcnJvclwiO1xuXG4gIGNvbnN0IGNvbnRleHRWYWx1ZTogQ2hhdENvbnRleHRUeXBlID0ge1xuICAgIG1lc3NhZ2VzLFxuICAgIHNlbmRNZXNzYWdlLFxuICAgIGlzQ29ubmVjdGVkLFxuICAgIGlzQ29ubmVjdGluZyxcbiAgICBoYXNFcnJvcixcbiAgICBjb25uZWN0aW9uU3RhdHVzOiBjb25uZWN0aW9uU3RhdGUsXG4gICAgcmVjb25uZWN0LFxuICAgIGFkZE1lc3NhZ2VMaXN0ZW5lcixcbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxDaGF0Q29udGV4dC5Qcm92aWRlciB2YWx1ZT17Y29udGV4dFZhbHVlfT5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L0NoYXRDb250ZXh0LlByb3ZpZGVyPlxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlQ2hhdCgpIHtcbiAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoQ2hhdENvbnRleHQpO1xuICBpZiAoIWNvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1c2VDaGF0IG11c3QgYmUgdXNlZCB3aXRoaW4gYSBDaGF0UHJvdmlkZXJcIik7XG4gIH1cbiAgcmV0dXJuIGNvbnRleHQ7XG59ICJdLCJuYW1lcyI6WyJSZWFjdCIsImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwidXNlRWZmZWN0IiwidXNlU3RhdGUiLCJ1c2VSZWYiLCJ1c2VDYWxsYmFjayIsIlNvY2tKUyIsIkNsaWVudCIsIkNoYXRDb250ZXh0IiwiZ2xvYmFsQ2xpZW50IiwiZ2xvYmFsQ29ubmVjdGlvblN0YXRlIiwibWVzc2FnZUxpc3RlbmVycyIsIlNldCIsInByb2Nlc3NlZE1lc3NhZ2VzIiwiQ2hhdFByb3ZpZGVyIiwiY2hpbGRyZW4iLCJ1c2VySWQiLCJtZXNzYWdlcyIsInNldE1lc3NhZ2VzIiwiY29ubmVjdGlvblN0YXRlIiwic2V0Q29ubmVjdGlvblN0YXRlIiwicmVjb25uZWN0VGltZW91dFJlZiIsImNvbm5lY3Rpb25BdHRlbXB0c1JlZiIsIm1heFJlY29ubmVjdEF0dGVtcHRzIiwicmVjb25uZWN0RGVsYXkiLCJpc0Nvbm5lY3RpbmdSZWYiLCJ1cGRhdGVDb25uZWN0aW9uU3RhdGUiLCJuZXdTdGF0ZSIsImFkZE1lc3NhZ2VMaXN0ZW5lciIsImxpc3RlbmVyIiwiYWRkIiwiZGVsZXRlIiwibm90aWZ5TWVzc2FnZUxpc3RlbmVycyIsIm1zZyIsImZvckVhY2giLCJlcnJvciIsImNvbnNvbGUiLCJjb25uZWN0IiwiY3VycmVudCIsImNvbm5lY3RlZCIsImxvZyIsImRlYWN0aXZhdGUiLCJ3YXJuIiwiY2xlYXJUaW1lb3V0Iiwic29ja2V0IiwiY2xpZW50Iiwid2ViU29ja2V0RmFjdG9yeSIsImhlYXJ0YmVhdEluY29taW5nIiwiaGVhcnRiZWF0T3V0Z29pbmciLCJvbkNvbm5lY3QiLCJzdWJzY3JpYmUiLCJtZXNzYWdlIiwiYm9keSIsIkpTT04iLCJwYXJzZSIsImNvbnRlbnQiLCJtZXNzYWdlS2V5IiwiaWQiLCJ0aW1lc3RhbXAiLCJEYXRlIiwibm93Iiwic2VuZGVySWQiLCJoYXMiLCJzaXplIiwibWVzc2FnZXNBcnJheSIsIkFycmF5IiwiZnJvbSIsImNsZWFyIiwic2xpY2UiLCJwcmV2Iiwiam9pbk1lc3NhZ2UiLCJzZW5kZXJOYW1lIiwicmVjZWl2ZXJJZCIsImxpc3RpbmdJZCIsInB1Ymxpc2giLCJkZXN0aW5hdGlvbiIsInN0cmluZ2lmeSIsIm9uRGlzY29ubmVjdCIsInNldFRpbWVvdXQiLCJvblN0b21wRXJyb3IiLCJvbldlYlNvY2tldEVycm9yIiwib25XZWJTb2NrZXRDbG9zZSIsImFjdGl2YXRlIiwic2VuZE1lc3NhZ2UiLCJyZWNvbm5lY3QiLCJpc0Nvbm5lY3RlZCIsImlzQ29ubmVjdGluZyIsImhhc0Vycm9yIiwiY29udGV4dFZhbHVlIiwiY29ubmVjdGlvblN0YXR1cyIsIlByb3ZpZGVyIiwidmFsdWUiLCJ1c2VDaGF0IiwiY29udGV4dCIsIkVycm9yIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/contexts/ChatContext.tsx\n"));

/***/ })

});