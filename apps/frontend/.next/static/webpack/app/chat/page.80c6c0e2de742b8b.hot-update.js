"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/chat/page",{

/***/ "(app-pages-browser)/./src/contexts/ChatContext.tsx":
/*!**************************************!*\
  !*** ./src/contexts/ChatContext.tsx ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChatProvider: () => (/* binding */ ChatProvider),\n/* harmony export */   useChat: () => (/* binding */ useChat)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/../../node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/../../node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var sockjs_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! sockjs-client */ \"(app-pages-browser)/../../node_modules/sockjs-client/lib/entry.js\");\n/* harmony import */ var sockjs_client__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(sockjs_client__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _stomp_stompjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @stomp/stompjs */ \"(app-pages-browser)/../../node_modules/@stomp/stompjs/esm6/client.js\");\n/* __next_internal_client_entry_do_not_use__ ChatProvider,useChat auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\nconst ChatContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\n// Global connection manager\nlet globalClient = null;\nlet globalConnectionState = \"disconnected\";\nlet messageListeners = new Set();\nlet processedMessages = new Set();\nfunction generateConversationId(userId1, userId2, listingId) {\n    return [\n        userId1,\n        userId2,\n        listingId\n    ].sort().join('_');\n}\nfunction ChatProvider(param) {\n    let { children, userId } = param;\n    _s();\n    const [messages, setMessages] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [connectionState, setConnectionState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"disconnected\");\n    const reconnectTimeoutRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const connectionAttemptsRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n    const maxReconnectAttempts = 3;\n    const reconnectDelay = 3000;\n    const isConnectingRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    const updateConnectionState = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"ChatProvider.useCallback[updateConnectionState]\": (newState)=>{\n            globalConnectionState = newState;\n            setConnectionState(newState);\n        }\n    }[\"ChatProvider.useCallback[updateConnectionState]\"], []);\n    const addMessageListener = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"ChatProvider.useCallback[addMessageListener]\": (listener)=>{\n            messageListeners.add(listener);\n            return ({\n                \"ChatProvider.useCallback[addMessageListener]\": ()=>{\n                    messageListeners.delete(listener);\n                }\n            })[\"ChatProvider.useCallback[addMessageListener]\"];\n        }\n    }[\"ChatProvider.useCallback[addMessageListener]\"], []);\n    const notifyMessageListeners = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"ChatProvider.useCallback[notifyMessageListeners]\": (msg)=>{\n            messageListeners.forEach({\n                \"ChatProvider.useCallback[notifyMessageListeners]\": (listener)=>{\n                    try {\n                        listener(msg);\n                    } catch (error) {\n                        console.error(\"Error in message listener:\", error);\n                    }\n                }\n            }[\"ChatProvider.useCallback[notifyMessageListeners]\"]);\n        }\n    }[\"ChatProvider.useCallback[notifyMessageListeners]\"], []);\n    const connect = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"ChatProvider.useCallback[connect]\": ()=>{\n            if (!userId || isConnectingRef.current) return;\n            // Check if there's already a global connection\n            if (globalClient && globalClient.connected) {\n                console.log(\"🔌 Using existing global WebSocket connection for user:\", userId);\n                updateConnectionState(\"connected\");\n                return;\n            }\n            // Clean up any existing connection\n            if (globalClient) {\n                try {\n                    globalClient.deactivate();\n                } catch (error) {\n                    console.warn(\"Error deactivating existing global client:\", error);\n                }\n                globalClient = null;\n            }\n            if (reconnectTimeoutRef.current) {\n                clearTimeout(reconnectTimeoutRef.current);\n                reconnectTimeoutRef.current = null;\n            }\n            connectionAttemptsRef.current = 0;\n            isConnectingRef.current = true;\n            console.log(\"🔌 Initializing global WebSocket connection for user:\", userId);\n            updateConnectionState(\"connecting\");\n            try {\n                const socket = new (sockjs_client__WEBPACK_IMPORTED_MODULE_2___default())(\"http://localhost:8081/ws\");\n                const client = new _stomp_stompjs__WEBPACK_IMPORTED_MODULE_3__.Client({\n                    webSocketFactory: {\n                        \"ChatProvider.useCallback[connect]\": ()=>socket\n                    }[\"ChatProvider.useCallback[connect]\"],\n                    reconnectDelay: 0,\n                    heartbeatIncoming: 4000,\n                    heartbeatOutgoing: 4000,\n                    onConnect: {\n                        \"ChatProvider.useCallback[connect]\": ()=>{\n                            console.log(\"✅ Global WebSocket connected successfully for user:\", userId);\n                            connectionAttemptsRef.current = 0;\n                            isConnectingRef.current = false;\n                            updateConnectionState(\"connected\");\n                            globalClient = client;\n                            // For demonstration, let's subscribe to a default test conversation\n                            const testReceiverId = \"seller123\"; // or get from state/context\n                            const testListingId = \"listing123\"; // or get from state/context\n                            const conversationId = generateConversationId(userId, testReceiverId, testListingId);\n                            client.subscribe(\"/topic/conversation/\".concat(conversationId), {\n                                \"ChatProvider.useCallback[connect]\": (message)=>{\n                                    try {\n                                        console.log(\"📨 Received conversation message:\", message.body);\n                                        const body = JSON.parse(message.body);\n                                        console.log(\"📨 Parsed conversation message:\", body);\n                                        if (body.content && body.content !== \"joined\") {\n                                            const messageKey = \"\".concat(body.id || body.timestamp || Date.now(), \"_\").concat(body.senderId, \"_\").concat(body.content);\n                                            if (processedMessages.has(messageKey)) {\n                                                console.log(\"📨 Skipping duplicate message:\", messageKey);\n                                                return;\n                                            }\n                                            processedMessages.add(messageKey);\n                                            if (processedMessages.size > 100) {\n                                                const messagesArray = Array.from(processedMessages);\n                                                processedMessages.clear();\n                                                messagesArray.slice(-50).forEach({\n                                                    \"ChatProvider.useCallback[connect]\": (msg)=>processedMessages.add(msg)\n                                                }[\"ChatProvider.useCallback[connect]\"]);\n                                            }\n                                            console.log(\"📨 Processing conversation message for user:\", userId, \"Message:\", body);\n                                            if ((body.senderId === userId || body.receiverId === userId) && body.conversationId === conversationId) {\n                                                console.log(\"📨 Adding message to local state for user:\", userId);\n                                                setMessages({\n                                                    \"ChatProvider.useCallback[connect]\": (prev)=>[\n                                                            ...prev,\n                                                            body\n                                                        ]\n                                                }[\"ChatProvider.useCallback[connect]\"]);\n                                                notifyMessageListeners(body);\n                                            } else {\n                                                console.log(\"📨 Message not for this user. Sender:\", body.senderId, \"Receiver:\", body.receiverId, \"Current user:\", userId);\n                                            }\n                                        } else {\n                                            console.log(\"📨 Ignoring join message\");\n                                        }\n                                    } catch (error) {\n                                        console.error(\"❌ Error parsing conversation message:\", error);\n                                    }\n                                }\n                            }[\"ChatProvider.useCallback[connect]\"]);\n                            // Send join message only once per connection\n                            const joinMessage = {\n                                senderId: userId,\n                                senderName: userId,\n                                content: \"joined\",\n                                receiverId: \"\",\n                                listingId: \"\"\n                            };\n                            console.log(\"👋 Sending join message:\", joinMessage);\n                            client.publish({\n                                destination: \"/app/chat.join\",\n                                body: JSON.stringify(joinMessage)\n                            });\n                        }\n                    }[\"ChatProvider.useCallback[connect]\"],\n                    onDisconnect: {\n                        \"ChatProvider.useCallback[connect]\": ()=>{\n                            console.log(\"❌ Global WebSocket disconnected for user:\", userId);\n                            isConnectingRef.current = false;\n                            updateConnectionState(\"disconnected\");\n                            globalClient = null;\n                            // Attempt to reconnect if we haven't exceeded max attempts\n                            if (connectionAttemptsRef.current < maxReconnectAttempts) {\n                                connectionAttemptsRef.current++;\n                                console.log(\"\\uD83D\\uDD04 Reconnection attempt \".concat(connectionAttemptsRef.current, \"/\").concat(maxReconnectAttempts, \" for user:\"), userId);\n                                reconnectTimeoutRef.current = setTimeout({\n                                    \"ChatProvider.useCallback[connect]\": ()=>{\n                                        connect();\n                                    }\n                                }[\"ChatProvider.useCallback[connect]\"], reconnectDelay);\n                            } else {\n                                console.error(\"❌ Max reconnection attempts reached for user:\", userId);\n                                updateConnectionState(\"error\");\n                            }\n                        }\n                    }[\"ChatProvider.useCallback[connect]\"],\n                    onStompError: {\n                        \"ChatProvider.useCallback[connect]\": (error)=>{\n                            console.error(\"❌ STOMP error for user\", userId, \":\", error);\n                            isConnectingRef.current = false;\n                            updateConnectionState(\"error\");\n                        }\n                    }[\"ChatProvider.useCallback[connect]\"],\n                    onWebSocketError: {\n                        \"ChatProvider.useCallback[connect]\": (error)=>{\n                            console.error(\"❌ WebSocket error for user\", userId, \":\", error);\n                            isConnectingRef.current = false;\n                            updateConnectionState(\"error\");\n                        }\n                    }[\"ChatProvider.useCallback[connect]\"],\n                    onWebSocketClose: {\n                        \"ChatProvider.useCallback[connect]\": ()=>{\n                            console.log(\"❌ Global WebSocket connection closed for user:\", userId);\n                            isConnectingRef.current = false;\n                            updateConnectionState(\"disconnected\");\n                        }\n                    }[\"ChatProvider.useCallback[connect]\"]\n                });\n                client.activate();\n            } catch (error) {\n                console.error(\"❌ Error creating global WebSocket connection for user\", userId, \":\", error);\n                isConnectingRef.current = false;\n                updateConnectionState(\"error\");\n            }\n        }\n    }[\"ChatProvider.useCallback[connect]\"], [\n        userId,\n        updateConnectionState,\n        notifyMessageListeners\n    ]);\n    const sendMessage = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"ChatProvider.useCallback[sendMessage]\": (msg)=>{\n            if (connectionState !== \"connected\" || !globalClient) {\n                console.error(\"❌ Cannot send message: not connected. State:\", connectionState);\n                return false;\n            }\n            try {\n                console.log(\"📤 Sending private message via global WebSocket:\", msg);\n                globalClient.publish({\n                    destination: \"/app/chat.private\",\n                    body: JSON.stringify(msg)\n                });\n                console.log(\"✅ Private message sent successfully via global WebSocket\");\n                return true;\n            } catch (error) {\n                console.error(\"❌ Error sending private message via global WebSocket:\", error);\n                return false;\n            }\n        }\n    }[\"ChatProvider.useCallback[sendMessage]\"], [\n        connectionState\n    ]);\n    const reconnect = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"ChatProvider.useCallback[reconnect]\": ()=>{\n            console.log(\"🔄 Manual reconnect requested for user:\", userId);\n            connectionAttemptsRef.current = 0;\n            isConnectingRef.current = false;\n            // Clean up existing connection\n            if (globalClient) {\n                try {\n                    globalClient.deactivate();\n                } catch (error) {\n                    console.warn(\"Error deactivating global client during manual reconnect:\", error);\n                }\n                globalClient = null;\n            }\n            if (reconnectTimeoutRef.current) {\n                clearTimeout(reconnectTimeoutRef.current);\n                reconnectTimeoutRef.current = null;\n            }\n            connect();\n        }\n    }[\"ChatProvider.useCallback[reconnect]\"], [\n        userId,\n        connect\n    ]);\n    // Initialize connection when userId changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ChatProvider.useEffect\": ()=>{\n            if (userId) {\n                connect();\n            } else {\n                updateConnectionState(\"disconnected\");\n            }\n            return ({\n                \"ChatProvider.useEffect\": ()=>{\n                    if (reconnectTimeoutRef.current) {\n                        clearTimeout(reconnectTimeoutRef.current);\n                    }\n                }\n            })[\"ChatProvider.useEffect\"];\n        }\n    }[\"ChatProvider.useEffect\"], [\n        userId,\n        connect,\n        updateConnectionState\n    ]);\n    const isConnected = connectionState === \"connected\";\n    const isConnecting = connectionState === \"connecting\";\n    const hasError = connectionState === \"error\";\n    const contextValue = {\n        messages,\n        sendMessage,\n        isConnected,\n        isConnecting,\n        hasError,\n        connectionStatus: connectionState,\n        reconnect,\n        addMessageListener\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ChatContext.Provider, {\n        value: contextValue,\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/nihal/Desktop/Nihal/Projects/listri/apps/frontend/src/contexts/ChatContext.tsx\",\n        lineNumber: 293,\n        columnNumber: 5\n    }, this);\n}\n_s(ChatProvider, \"4oKLfQnyD9prkbVAW9bL6EmZx5Q=\");\n_c = ChatProvider;\nfunction useChat() {\n    _s1();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(ChatContext);\n    if (!context) {\n        throw new Error(\"useChat must be used within a ChatProvider\");\n    }\n    return context;\n}\n_s1(useChat, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"ChatProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb250ZXh0cy9DaGF0Q29udGV4dC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUVtRztBQUNoRTtBQUNLO0FBMEJ4QyxNQUFNUyw0QkFBY1Isb0RBQWFBLENBQXlCO0FBRTFELDRCQUE0QjtBQUM1QixJQUFJUyxlQUE4QjtBQUNsQyxJQUFJQyx3QkFBeUM7QUFDN0MsSUFBSUMsbUJBQW9ELElBQUlDO0FBQzVELElBQUlDLG9CQUFvQixJQUFJRDtBQUU1QixTQUFTRSx1QkFBdUJDLE9BQU8sRUFBRUMsT0FBTyxFQUFFQyxTQUFTO0lBQ3pELE9BQU87UUFBQ0Y7UUFBU0M7UUFBU0M7S0FBVSxDQUFDQyxJQUFJLEdBQUdDLElBQUksQ0FBQztBQUNuRDtBQUVPLFNBQVNDLGFBQWEsS0FBbUU7UUFBbkUsRUFBRUMsUUFBUSxFQUFFQyxNQUFNLEVBQWlELEdBQW5FOztJQUMzQixNQUFNLENBQUNDLFVBQVVDLFlBQVksR0FBR3JCLCtDQUFRQSxDQUFnQixFQUFFO0lBQzFELE1BQU0sQ0FBQ3NCLGlCQUFpQkMsbUJBQW1CLEdBQUd2QiwrQ0FBUUEsQ0FBa0I7SUFDeEUsTUFBTXdCLHNCQUFzQnZCLDZDQUFNQSxDQUF3QjtJQUMxRCxNQUFNd0Isd0JBQXdCeEIsNkNBQU1BLENBQUM7SUFDckMsTUFBTXlCLHVCQUF1QjtJQUM3QixNQUFNQyxpQkFBaUI7SUFDdkIsTUFBTUMsa0JBQWtCM0IsNkNBQU1BLENBQUM7SUFFL0IsTUFBTTRCLHdCQUF3QjNCLGtEQUFXQTsyREFBQyxDQUFDNEI7WUFDekN2Qix3QkFBd0J1QjtZQUN4QlAsbUJBQW1CTztRQUNyQjswREFBRyxFQUFFO0lBRUwsTUFBTUMscUJBQXFCN0Isa0RBQVdBO3dEQUFDLENBQUM4QjtZQUN0Q3hCLGlCQUFpQnlCLEdBQUcsQ0FBQ0Q7WUFDckI7Z0VBQU87b0JBQ0x4QixpQkFBaUIwQixNQUFNLENBQUNGO2dCQUMxQjs7UUFDRjt1REFBRyxFQUFFO0lBRUws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UUFDbEJtRTtRQUNBMUQ7SUFDRjtJQUVBLHFCQUNFLDhEQUFDMUIsWUFBWTBGLFFBQVE7UUFBQ0MsT0FBT0g7a0JBQzFCM0U7Ozs7OztBQUdQO0dBOVBnQkQ7S0FBQUE7QUFnUVQsU0FBU2dGOztJQUNkLE1BQU1DLFVBQVVwRyxpREFBVUEsQ0FBQ087SUFDM0IsSUFBSSxDQUFDNkYsU0FBUztRQUNaLE1BQU0sSUFBSUMsTUFBTTtJQUNsQjtJQUNBLE9BQU9EO0FBQ1Q7SUFOZ0JEIiwic291cmNlcyI6WyIvVXNlcnMvbmloYWwvRGVza3RvcC9OaWhhbC9Qcm9qZWN0cy9saXN0cmkvYXBwcy9mcm9udGVuZC9zcmMvY29udGV4dHMvQ2hhdENvbnRleHQudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXG5pbXBvcnQgUmVhY3QsIHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlRWZmZWN0LCB1c2VTdGF0ZSwgdXNlUmVmLCB1c2VDYWxsYmFjayB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IFNvY2tKUyBmcm9tIFwic29ja2pzLWNsaWVudFwiO1xuaW1wb3J0IHsgQ2xpZW50IH0gZnJvbSBcIkBzdG9tcC9zdG9tcGpzXCI7XG5cbmV4cG9ydCB0eXBlIENoYXRNZXNzYWdlID0ge1xuICBpZD86IHN0cmluZztcbiAgY29udmVyc2F0aW9uSWQ/OiBzdHJpbmc7XG4gIHNlbmRlcklkOiBzdHJpbmc7XG4gIHNlbmRlck5hbWU6IHN0cmluZztcbiAgcmVjZWl2ZXJJZDogc3RyaW5nO1xuICBjb250ZW50OiBzdHJpbmc7XG4gIHRpbWVzdGFtcD86IHN0cmluZztcbiAgbGlzdGluZ0lkOiBzdHJpbmc7XG59O1xuXG50eXBlIENvbm5lY3Rpb25TdGF0ZSA9IFwiZGlzY29ubmVjdGVkXCIgfCBcImNvbm5lY3RpbmdcIiB8IFwiY29ubmVjdGVkXCIgfCBcImVycm9yXCI7XG5cbmludGVyZmFjZSBDaGF0Q29udGV4dFR5cGUge1xuICBtZXNzYWdlczogQ2hhdE1lc3NhZ2VbXTtcbiAgc2VuZE1lc3NhZ2U6IChtc2c6IENoYXRNZXNzYWdlKSA9PiBib29sZWFuO1xuICBpc0Nvbm5lY3RlZDogYm9vbGVhbjtcbiAgaXNDb25uZWN0aW5nOiBib29sZWFuO1xuICBoYXNFcnJvcjogYm9vbGVhbjtcbiAgY29ubmVjdGlvblN0YXR1czogQ29ubmVjdGlvblN0YXRlO1xuICByZWNvbm5lY3Q6ICgpID0+IHZvaWQ7XG4gIGFkZE1lc3NhZ2VMaXN0ZW5lcjogKGxpc3RlbmVyOiAobXNnOiBDaGF0TWVzc2FnZSkgPT4gdm9pZCkgPT4gKCkgPT4gdm9pZDtcbn1cblxuY29uc3QgQ2hhdENvbnRleHQgPSBjcmVhdGVDb250ZXh0PENoYXRDb250ZXh0VHlwZSB8IG51bGw+KG51bGwpO1xuXG4vLyBHbG9iYWwgY29ubmVjdGlvbiBtYW5hZ2VyXG5sZXQgZ2xvYmFsQ2xpZW50OiBDbGllbnQgfCBudWxsID0gbnVsbDtcbmxldCBnbG9iYWxDb25uZWN0aW9uU3RhdGU6IENvbm5lY3Rpb25TdGF0ZSA9IFwiZGlzY29ubmVjdGVkXCI7XG5sZXQgbWVzc2FnZUxpc3RlbmVyczogU2V0PChtc2c6IENoYXRNZXNzYWdlKSA9PiB2b2lkPiA9IG5ldyBTZXQoKTtcbmxldCBwcm9jZXNzZWRNZXNzYWdlcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXG5mdW5jdGlvbiBnZW5lcmF0ZUNvbnZlcnNhdGlvbklkKHVzZXJJZDEsIHVzZXJJZDIsIGxpc3RpbmdJZCkge1xuICByZXR1cm4gW3VzZXJJZDEsIHVzZXJJZDIsIGxpc3RpbmdJZF0uc29ydCgpLmpvaW4oJ18nKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIENoYXRQcm92aWRlcih7IGNoaWxkcmVuLCB1c2VySWQgfTogeyBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlOyB1c2VySWQ6IHN0cmluZyB9KSB7XG4gIGNvbnN0IFttZXNzYWdlcywgc2V0TWVzc2FnZXNdID0gdXNlU3RhdGU8Q2hhdE1lc3NhZ2VbXT4oW10pO1xuICBjb25zdCBbY29ubmVjdGlvblN0YXRlLCBzZXRDb25uZWN0aW9uU3RhdGVdID0gdXNlU3RhdGU8Q29ubmVjdGlvblN0YXRlPihcImRpc2Nvbm5lY3RlZFwiKTtcbiAgY29uc3QgcmVjb25uZWN0VGltZW91dFJlZiA9IHVzZVJlZjxOb2RlSlMuVGltZW91dCB8IG51bGw+KG51bGwpO1xuICBjb25zdCBjb25uZWN0aW9uQXR0ZW1wdHNSZWYgPSB1c2VSZWYoMCk7XG4gIGNvbnN0IG1heFJlY29ubmVjdEF0dGVtcHRzID0gMztcbiAgY29uc3QgcmVjb25uZWN0RGVsYXkgPSAzMDAwO1xuICBjb25zdCBpc0Nvbm5lY3RpbmdSZWYgPSB1c2VSZWYoZmFsc2UpO1xuXG4gIGNvbnN0IHVwZGF0ZUNvbm5lY3Rpb25TdGF0ZSA9IHVzZUNhbGxiYWNrKChuZXdTdGF0ZTogQ29ubmVjdGlvblN0YXRlKSA9PiB7XG4gICAgZ2xvYmFsQ29ubmVjdGlvblN0YXRlID0gbmV3U3RhdGU7XG4gICAgc2V0Q29ubmVjdGlvblN0YXRlKG5ld1N0YXRlKTtcbiAgfSwgW10pO1xuXG4gIGNvbnN0IGFkZE1lc3NhZ2VMaXN0ZW5lciA9IHVzZUNhbGxiYWNrKChsaXN0ZW5lcjogKG1zZzogQ2hhdE1lc3NhZ2UpID0+IHZvaWQpID0+IHtcbiAgICBtZXNzYWdlTGlzdGVuZXJzLmFkZChsaXN0ZW5lcik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIG1lc3NhZ2VMaXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICB9O1xuICB9LCBbXSk7XG5cbiAgY29uc3Qgbm90aWZ5TWVzc2FnZUxpc3RlbmVycyA9IHVzZUNhbGxiYWNrKChtc2c6IENoYXRNZXNzYWdlKSA9PiB7XG4gICAgbWVzc2FnZUxpc3RlbmVycy5mb3JFYWNoKGxpc3RlbmVyID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxpc3RlbmVyKG1zZyk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW4gbWVzc2FnZSBsaXN0ZW5lcjpcIiwgZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LCBbXSk7XG5cbiAgY29uc3QgY29ubmVjdCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoIXVzZXJJZCB8fCBpc0Nvbm5lY3RpbmdSZWYuY3VycmVudCkgcmV0dXJuO1xuXG4gICAgLy8gQ2hlY2sgaWYgdGhlcmUncyBhbHJlYWR5IGEgZ2xvYmFsIGNvbm5lY3Rpb25cbiAgICBpZiAoZ2xvYmFsQ2xpZW50ICYmIGdsb2JhbENsaWVudC5jb25uZWN0ZWQpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwi8J+UjCBVc2luZyBleGlzdGluZyBnbG9iYWwgV2ViU29ja2V0IGNvbm5lY3Rpb24gZm9yIHVzZXI6XCIsIHVzZXJJZCk7XG4gICAgICB1cGRhdGVDb25uZWN0aW9uU3RhdGUoXCJjb25uZWN0ZWRcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ2xlYW4gdXAgYW55IGV4aXN0aW5nIGNvbm5lY3Rpb25cbiAgICBpZiAoZ2xvYmFsQ2xpZW50KSB7XG4gICAgICB0cnkge1xuICAgICAgICBnbG9iYWxDbGllbnQuZGVhY3RpdmF0ZSgpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiRXJyb3IgZGVhY3RpdmF0aW5nIGV4aXN0aW5nIGdsb2JhbCBjbGllbnQ6XCIsIGVycm9yKTtcbiAgICAgIH1cbiAgICAgIGdsb2JhbENsaWVudCA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHJlY29ubmVjdFRpbWVvdXRSZWYuY3VycmVudCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHJlY29ubmVjdFRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgICByZWNvbm5lY3RUaW1lb3V0UmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cblxuICAgIGNvbm5lY3Rpb25BdHRlbXB0c1JlZi5jdXJyZW50ID0gMDtcbiAgICBpc0Nvbm5lY3RpbmdSZWYuY3VycmVudCA9IHRydWU7XG4gICAgXG4gICAgY29uc29sZS5sb2coXCLwn5SMIEluaXRpYWxpemluZyBnbG9iYWwgV2ViU29ja2V0IGNvbm5lY3Rpb24gZm9yIHVzZXI6XCIsIHVzZXJJZCk7XG4gICAgdXBkYXRlQ29ubmVjdGlvblN0YXRlKFwiY29ubmVjdGluZ1wiKTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBzb2NrZXQgPSBuZXcgU29ja0pTKFwiaHR0cDovL2xvY2FsaG9zdDo4MDgxL3dzXCIpO1xuICAgICAgXG4gICAgICBjb25zdCBjbGllbnQgPSBuZXcgQ2xpZW50KHtcbiAgICAgICAgd2ViU29ja2V0RmFjdG9yeTogKCkgPT4gc29ja2V0LFxuICAgICAgICByZWNvbm5lY3REZWxheTogMCwgLy8gRGlzYWJsZSBhdXRvbWF0aWMgcmVjb25uZWN0aW9uXG4gICAgICAgIGhlYXJ0YmVhdEluY29taW5nOiA0MDAwLFxuICAgICAgICBoZWFydGJlYXRPdXRnb2luZzogNDAwMCxcbiAgICAgICAgb25Db25uZWN0OiAoKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCLinIUgR2xvYmFsIFdlYlNvY2tldCBjb25uZWN0ZWQgc3VjY2Vzc2Z1bGx5IGZvciB1c2VyOlwiLCB1c2VySWQpO1xuICAgICAgICAgIGNvbm5lY3Rpb25BdHRlbXB0c1JlZi5jdXJyZW50ID0gMDtcbiAgICAgICAgICBpc0Nvbm5lY3RpbmdSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgIHVwZGF0ZUNvbm5lY3Rpb25TdGF0ZShcImNvbm5lY3RlZFwiKTtcbiAgICAgICAgICBcbiAgICAgICAgICBnbG9iYWxDbGllbnQgPSBjbGllbnQ7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRm9yIGRlbW9uc3RyYXRpb24sIGxldCdzIHN1YnNjcmliZSB0byBhIGRlZmF1bHQgdGVzdCBjb252ZXJzYXRpb25cbiAgICAgICAgICBjb25zdCB0ZXN0UmVjZWl2ZXJJZCA9IFwic2VsbGVyMTIzXCI7IC8vIG9yIGdldCBmcm9tIHN0YXRlL2NvbnRleHRcbiAgICAgICAgICBjb25zdCB0ZXN0TGlzdGluZ0lkID0gXCJsaXN0aW5nMTIzXCI7IC8vIG9yIGdldCBmcm9tIHN0YXRlL2NvbnRleHRcbiAgICAgICAgICBjb25zdCBjb252ZXJzYXRpb25JZCA9IGdlbmVyYXRlQ29udmVyc2F0aW9uSWQodXNlcklkLCB0ZXN0UmVjZWl2ZXJJZCwgdGVzdExpc3RpbmdJZCk7XG4gICAgICAgICAgY2xpZW50LnN1YnNjcmliZShgL3RvcGljL2NvbnZlcnNhdGlvbi8ke2NvbnZlcnNhdGlvbklkfWAsIChtZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIvCfk6ggUmVjZWl2ZWQgY29udmVyc2F0aW9uIG1lc3NhZ2U6XCIsIG1lc3NhZ2UuYm9keSk7XG4gICAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnBhcnNlKG1lc3NhZ2UuYm9keSk7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi8J+TqCBQYXJzZWQgY29udmVyc2F0aW9uIG1lc3NhZ2U6XCIsIGJvZHkpO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgaWYgKGJvZHkuY29udGVudCAmJiBib2R5LmNvbnRlbnQgIT09IFwiam9pbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlS2V5ID0gYCR7Ym9keS5pZCB8fCBib2R5LnRpbWVzdGFtcCB8fCBEYXRlLm5vdygpfV8ke2JvZHkuc2VuZGVySWR9XyR7Ym9keS5jb250ZW50fWA7XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3NlZE1lc3NhZ2VzLmhhcyhtZXNzYWdlS2V5KSkge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCLwn5OoIFNraXBwaW5nIGR1cGxpY2F0ZSBtZXNzYWdlOlwiLCBtZXNzYWdlS2V5KTtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJvY2Vzc2VkTWVzc2FnZXMuYWRkKG1lc3NhZ2VLZXkpO1xuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzZWRNZXNzYWdlcy5zaXplID4gMTAwKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlc0FycmF5ID0gQXJyYXkuZnJvbShwcm9jZXNzZWRNZXNzYWdlcyk7XG4gICAgICAgICAgICAgICAgICBwcm9jZXNzZWRNZXNzYWdlcy5jbGVhcigpO1xuICAgICAgICAgICAgICAgICAgbWVzc2FnZXNBcnJheS5zbGljZSgtNTApLmZvckVhY2gobXNnID0+IHByb2Nlc3NlZE1lc3NhZ2VzLmFkZChtc2cpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCLwn5OoIFByb2Nlc3NpbmcgY29udmVyc2F0aW9uIG1lc3NhZ2UgZm9yIHVzZXI6XCIsIHVzZXJJZCwgXCJNZXNzYWdlOlwiLCBib2R5KTtcbiAgICAgICAgICAgICAgICBpZiAoKGJvZHkuc2VuZGVySWQgPT09IHVzZXJJZCB8fCBib2R5LnJlY2VpdmVySWQgPT09IHVzZXJJZCkgJiYgYm9keS5jb252ZXJzYXRpb25JZCA9PT0gY29udmVyc2F0aW9uSWQpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi8J+TqCBBZGRpbmcgbWVzc2FnZSB0byBsb2NhbCBzdGF0ZSBmb3IgdXNlcjpcIiwgdXNlcklkKTtcbiAgICAgICAgICAgICAgICAgIHNldE1lc3NhZ2VzKHByZXYgPT4gWy4uLnByZXYsIGJvZHldKTtcbiAgICAgICAgICAgICAgICAgIG5vdGlmeU1lc3NhZ2VMaXN0ZW5lcnMoYm9keSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi8J+TqCBNZXNzYWdlIG5vdCBmb3IgdGhpcyB1c2VyLiBTZW5kZXI6XCIsIGJvZHkuc2VuZGVySWQsIFwiUmVjZWl2ZXI6XCIsIGJvZHkucmVjZWl2ZXJJZCwgXCJDdXJyZW50IHVzZXI6XCIsIHVzZXJJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi8J+TqCBJZ25vcmluZyBqb2luIG1lc3NhZ2VcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCLinYwgRXJyb3IgcGFyc2luZyBjb252ZXJzYXRpb24gbWVzc2FnZTpcIiwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gU2VuZCBqb2luIG1lc3NhZ2Ugb25seSBvbmNlIHBlciBjb25uZWN0aW9uXG4gICAgICAgICAgY29uc3Qgam9pbk1lc3NhZ2UgPSB7XG4gICAgICAgICAgICBzZW5kZXJJZDogdXNlcklkLFxuICAgICAgICAgICAgc2VuZGVyTmFtZTogdXNlcklkLFxuICAgICAgICAgICAgY29udGVudDogXCJqb2luZWRcIixcbiAgICAgICAgICAgIHJlY2VpdmVySWQ6IFwiXCIsXG4gICAgICAgICAgICBsaXN0aW5nSWQ6IFwiXCJcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwi8J+RiyBTZW5kaW5nIGpvaW4gbWVzc2FnZTpcIiwgam9pbk1lc3NhZ2UpO1xuICAgICAgICAgIGNsaWVudC5wdWJsaXNoKHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uOiBcIi9hcHAvY2hhdC5qb2luXCIsXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShqb2luTWVzc2FnZSksXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uRGlzY29ubmVjdDogKCkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwi4p2MIEdsb2JhbCBXZWJTb2NrZXQgZGlzY29ubmVjdGVkIGZvciB1c2VyOlwiLCB1c2VySWQpO1xuICAgICAgICAgIGlzQ29ubmVjdGluZ1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgdXBkYXRlQ29ubmVjdGlvblN0YXRlKFwiZGlzY29ubmVjdGVkXCIpO1xuICAgICAgICAgIFxuICAgICAgICAgIGdsb2JhbENsaWVudCA9IG51bGw7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQXR0ZW1wdCB0byByZWNvbm5lY3QgaWYgd2UgaGF2ZW4ndCBleGNlZWRlZCBtYXggYXR0ZW1wdHNcbiAgICAgICAgICBpZiAoY29ubmVjdGlvbkF0dGVtcHRzUmVmLmN1cnJlbnQgPCBtYXhSZWNvbm5lY3RBdHRlbXB0cykge1xuICAgICAgICAgICAgY29ubmVjdGlvbkF0dGVtcHRzUmVmLmN1cnJlbnQrKztcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5SEIFJlY29ubmVjdGlvbiBhdHRlbXB0ICR7Y29ubmVjdGlvbkF0dGVtcHRzUmVmLmN1cnJlbnR9LyR7bWF4UmVjb25uZWN0QXR0ZW1wdHN9IGZvciB1c2VyOmAsIHVzZXJJZCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJlY29ubmVjdFRpbWVvdXRSZWYuY3VycmVudCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICBjb25uZWN0KCk7XG4gICAgICAgICAgICB9LCByZWNvbm5lY3REZWxheSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCLinYwgTWF4IHJlY29ubmVjdGlvbiBhdHRlbXB0cyByZWFjaGVkIGZvciB1c2VyOlwiLCB1c2VySWQpO1xuICAgICAgICAgICAgdXBkYXRlQ29ubmVjdGlvblN0YXRlKFwiZXJyb3JcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvblN0b21wRXJyb3I6IChlcnJvcikgPT4ge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCLinYwgU1RPTVAgZXJyb3IgZm9yIHVzZXJcIiwgdXNlcklkLCBcIjpcIiwgZXJyb3IpO1xuICAgICAgICAgIGlzQ29ubmVjdGluZ1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgdXBkYXRlQ29ubmVjdGlvblN0YXRlKFwiZXJyb3JcIik7XG4gICAgICAgIH0sXG4gICAgICAgIG9uV2ViU29ja2V0RXJyb3I6IChlcnJvcikgPT4ge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCLinYwgV2ViU29ja2V0IGVycm9yIGZvciB1c2VyXCIsIHVzZXJJZCwgXCI6XCIsIGVycm9yKTtcbiAgICAgICAgICBpc0Nvbm5lY3RpbmdSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgIHVwZGF0ZUNvbm5lY3Rpb25TdGF0ZShcImVycm9yXCIpO1xuICAgICAgICB9LFxuICAgICAgICBvbldlYlNvY2tldENsb3NlOiAoKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCLinYwgR2xvYmFsIFdlYlNvY2tldCBjb25uZWN0aW9uIGNsb3NlZCBmb3IgdXNlcjpcIiwgdXNlcklkKTtcbiAgICAgICAgICBpc0Nvbm5lY3RpbmdSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgIHVwZGF0ZUNvbm5lY3Rpb25TdGF0ZShcImRpc2Nvbm5lY3RlZFwiKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGNsaWVudC5hY3RpdmF0ZSgpO1xuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCLinYwgRXJyb3IgY3JlYXRpbmcgZ2xvYmFsIFdlYlNvY2tldCBjb25uZWN0aW9uIGZvciB1c2VyXCIsIHVzZXJJZCwgXCI6XCIsIGVycm9yKTtcbiAgICAgIGlzQ29ubmVjdGluZ1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICB1cGRhdGVDb25uZWN0aW9uU3RhdGUoXCJlcnJvclwiKTtcbiAgICB9XG4gIH0sIFt1c2VySWQsIHVwZGF0ZUNvbm5lY3Rpb25TdGF0ZSwgbm90aWZ5TWVzc2FnZUxpc3RlbmVyc10pO1xuXG4gIGNvbnN0IHNlbmRNZXNzYWdlID0gdXNlQ2FsbGJhY2soKG1zZzogQ2hhdE1lc3NhZ2UpOiBib29sZWFuID0+IHtcbiAgICBpZiAoY29ubmVjdGlvblN0YXRlICE9PSBcImNvbm5lY3RlZFwiIHx8ICFnbG9iYWxDbGllbnQpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCLinYwgQ2Fubm90IHNlbmQgbWVzc2FnZTogbm90IGNvbm5lY3RlZC4gU3RhdGU6XCIsIGNvbm5lY3Rpb25TdGF0ZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKFwi8J+TpCBTZW5kaW5nIHByaXZhdGUgbWVzc2FnZSB2aWEgZ2xvYmFsIFdlYlNvY2tldDpcIiwgbXNnKTtcbiAgICAgIGdsb2JhbENsaWVudC5wdWJsaXNoKHtcbiAgICAgICAgZGVzdGluYXRpb246IFwiL2FwcC9jaGF0LnByaXZhdGVcIixcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkobXNnKSxcbiAgICAgIH0pO1xuICAgICAgY29uc29sZS5sb2coXCLinIUgUHJpdmF0ZSBtZXNzYWdlIHNlbnQgc3VjY2Vzc2Z1bGx5IHZpYSBnbG9iYWwgV2ViU29ja2V0XCIpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCLinYwgRXJyb3Igc2VuZGluZyBwcml2YXRlIG1lc3NhZ2UgdmlhIGdsb2JhbCBXZWJTb2NrZXQ6XCIsIGVycm9yKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIFtjb25uZWN0aW9uU3RhdGVdKTtcblxuICBjb25zdCByZWNvbm5lY3QgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgY29uc29sZS5sb2coXCLwn5SEIE1hbnVhbCByZWNvbm5lY3QgcmVxdWVzdGVkIGZvciB1c2VyOlwiLCB1c2VySWQpO1xuICAgIGNvbm5lY3Rpb25BdHRlbXB0c1JlZi5jdXJyZW50ID0gMDtcbiAgICBpc0Nvbm5lY3RpbmdSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgIFxuICAgIC8vIENsZWFuIHVwIGV4aXN0aW5nIGNvbm5lY3Rpb25cbiAgICBpZiAoZ2xvYmFsQ2xpZW50KSB7XG4gICAgICB0cnkge1xuICAgICAgICBnbG9iYWxDbGllbnQuZGVhY3RpdmF0ZSgpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiRXJyb3IgZGVhY3RpdmF0aW5nIGdsb2JhbCBjbGllbnQgZHVyaW5nIG1hbnVhbCByZWNvbm5lY3Q6XCIsIGVycm9yKTtcbiAgICAgIH1cbiAgICAgIGdsb2JhbENsaWVudCA9IG51bGw7XG4gICAgfVxuICAgIFxuICAgIGlmIChyZWNvbm5lY3RUaW1lb3V0UmVmLmN1cnJlbnQpIHtcbiAgICAgIGNsZWFyVGltZW91dChyZWNvbm5lY3RUaW1lb3V0UmVmLmN1cnJlbnQpO1xuICAgICAgcmVjb25uZWN0VGltZW91dFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gICAgXG4gICAgY29ubmVjdCgpO1xuICB9LCBbdXNlcklkLCBjb25uZWN0XSk7XG5cbiAgLy8gSW5pdGlhbGl6ZSBjb25uZWN0aW9uIHdoZW4gdXNlcklkIGNoYW5nZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodXNlcklkKSB7XG4gICAgICBjb25uZWN0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVwZGF0ZUNvbm5lY3Rpb25TdGF0ZShcImRpc2Nvbm5lY3RlZFwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKHJlY29ubmVjdFRpbWVvdXRSZWYuY3VycmVudCkge1xuICAgICAgICBjbGVhclRpbWVvdXQocmVjb25uZWN0VGltZW91dFJlZi5jdXJyZW50KTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbdXNlcklkLCBjb25uZWN0LCB1cGRhdGVDb25uZWN0aW9uU3RhdGVdKTtcblxuICBjb25zdCBpc0Nvbm5lY3RlZCA9IGNvbm5lY3Rpb25TdGF0ZSA9PT0gXCJjb25uZWN0ZWRcIjtcbiAgY29uc3QgaXNDb25uZWN0aW5nID0gY29ubmVjdGlvblN0YXRlID09PSBcImNvbm5lY3RpbmdcIjtcbiAgY29uc3QgaGFzRXJyb3IgPSBjb25uZWN0aW9uU3RhdGUgPT09IFwiZXJyb3JcIjtcblxuICBjb25zdCBjb250ZXh0VmFsdWU6IENoYXRDb250ZXh0VHlwZSA9IHtcbiAgICBtZXNzYWdlcyxcbiAgICBzZW5kTWVzc2FnZSxcbiAgICBpc0Nvbm5lY3RlZCxcbiAgICBpc0Nvbm5lY3RpbmcsXG4gICAgaGFzRXJyb3IsXG4gICAgY29ubmVjdGlvblN0YXR1czogY29ubmVjdGlvblN0YXRlLFxuICAgIHJlY29ubmVjdCxcbiAgICBhZGRNZXNzYWdlTGlzdGVuZXIsXG4gIH07XG5cbiAgcmV0dXJuIChcbiAgICA8Q2hhdENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e2NvbnRleHRWYWx1ZX0+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgPC9DaGF0Q29udGV4dC5Qcm92aWRlcj5cbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUNoYXQoKSB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KENoYXRDb250ZXh0KTtcbiAgaWYgKCFjb250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidXNlQ2hhdCBtdXN0IGJlIHVzZWQgd2l0aGluIGEgQ2hhdFByb3ZpZGVyXCIpO1xuICB9XG4gIHJldHVybiBjb250ZXh0O1xufSAiXSwibmFtZXMiOlsiUmVhY3QiLCJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsInVzZUVmZmVjdCIsInVzZVN0YXRlIiwidXNlUmVmIiwidXNlQ2FsbGJhY2siLCJTb2NrSlMiLCJDbGllbnQiLCJDaGF0Q29udGV4dCIsImdsb2JhbENsaWVudCIsImdsb2JhbENvbm5lY3Rpb25TdGF0ZSIsIm1lc3NhZ2VMaXN0ZW5lcnMiLCJTZXQiLCJwcm9jZXNzZWRNZXNzYWdlcyIsImdlbmVyYXRlQ29udmVyc2F0aW9uSWQiLCJ1c2VySWQxIiwidXNlcklkMiIsImxpc3RpbmdJZCIsInNvcnQiLCJqb2luIiwiQ2hhdFByb3ZpZGVyIiwiY2hpbGRyZW4iLCJ1c2VySWQiLCJtZXNzYWdlcyIsInNldE1lc3NhZ2VzIiwiY29ubmVjdGlvblN0YXRlIiwic2V0Q29ubmVjdGlvblN0YXRlIiwicmVjb25uZWN0VGltZW91dFJlZiIsImNvbm5lY3Rpb25BdHRlbXB0c1JlZiIsIm1heFJlY29ubmVjdEF0dGVtcHRzIiwicmVjb25uZWN0RGVsYXkiLCJpc0Nvbm5lY3RpbmdSZWYiLCJ1cGRhdGVDb25uZWN0aW9uU3RhdGUiLCJuZXdTdGF0ZSIsImFkZE1lc3NhZ2VMaXN0ZW5lciIsImxpc3RlbmVyIiwiYWRkIiwiZGVsZXRlIiwibm90aWZ5TWVzc2FnZUxpc3RlbmVycyIsIm1zZyIsImZvckVhY2giLCJlcnJvciIsImNvbnNvbGUiLCJjb25uZWN0IiwiY3VycmVudCIsImNvbm5lY3RlZCIsImxvZyIsImRlYWN0aXZhdGUiLCJ3YXJuIiwiY2xlYXJUaW1lb3V0Iiwic29ja2V0IiwiY2xpZW50Iiwid2ViU29ja2V0RmFjdG9yeSIsImhlYXJ0YmVhdEluY29taW5nIiwiaGVhcnRiZWF0T3V0Z29pbmciLCJvbkNvbm5lY3QiLCJ0ZXN0UmVjZWl2ZXJJZCIsInRlc3RMaXN0aW5nSWQiLCJjb252ZXJzYXRpb25JZCIsInN1YnNjcmliZSIsIm1lc3NhZ2UiLCJib2R5IiwiSlNPTiIsInBhcnNlIiwiY29udGVudCIsIm1lc3NhZ2VLZXkiLCJpZCIsInRpbWVzdGFtcCIsIkRhdGUiLCJub3ciLCJzZW5kZXJJZCIsImhhcyIsInNpemUiLCJtZXNzYWdlc0FycmF5IiwiQXJyYXkiLCJmcm9tIiwiY2xlYXIiLCJzbGljZSIsInJlY2VpdmVySWQiLCJwcmV2Iiwiam9pbk1lc3NhZ2UiLCJzZW5kZXJOYW1lIiwicHVibGlzaCIsImRlc3RpbmF0aW9uIiwic3RyaW5naWZ5Iiwib25EaXNjb25uZWN0Iiwic2V0VGltZW91dCIsIm9uU3RvbXBFcnJvciIsIm9uV2ViU29ja2V0RXJyb3IiLCJvbldlYlNvY2tldENsb3NlIiwiYWN0aXZhdGUiLCJzZW5kTWVzc2FnZSIsInJlY29ubmVjdCIsImlzQ29ubmVjdGVkIiwiaXNDb25uZWN0aW5nIiwiaGFzRXJyb3IiLCJjb250ZXh0VmFsdWUiLCJjb25uZWN0aW9uU3RhdHVzIiwiUHJvdmlkZXIiLCJ2YWx1ZSIsInVzZUNoYXQiLCJjb250ZXh0IiwiRXJyb3IiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/contexts/ChatContext.tsx\n"));

/***/ })

});